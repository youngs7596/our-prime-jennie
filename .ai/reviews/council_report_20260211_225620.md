# Prime Council Report
- Date: 2026-02-11 22:59:08
- Query: 
## 배경: 모멘텀 전략의 구조적 '상투 잡기' 문제

한국 주식 자동매매 시스템(My Prime Jennie)에서 모멘텀 기반 매수 전략이 반복적으로 고점 매수(상투 잡기)를 하고 있습니다.

### 현재 구현 구조

1. **BarAggregator**: WebSocket 틱 → 1분봉 생성 (bar_interval=60초)
2. **시그널 평가 시점**: 1분봉 **완성 후** 전략 체크 (최대 60초 지연)
3. **current_price**: bars[-1]['close'] — 완성된 봉의 종가 (이미 과거)
4. **실행**: RabbitMQ → buy-executor → KIS API 시장가(price=0) 주문

### 활성화된 모멘텀 전략들 (opportunity_watcher.py)

- **MOMENTUM**: 전체 바(최대 60분) 시작→현재 +1.5% 이상
- **MOMENTUM_CONTINUATION_BULL**: MA5>MA20 + 당일 +2% 이상 + LLM≥65
- **SHORT_TERM_HIGH_BREAKOUT**: 30분 고가 돌파 + 거래량 2x
- **VCP_BREAKOUT**: 변동성 축소 후 돌파 + 거래량 3x

### 문제 분석

**지연 누적 (총 30~90초)**:
1. 1분봉 완성 대기: 평균 ~30초 (봉 중간에 조건 충족해도 끝까지 기다림)
2. RabbitMQ + Executor 처리: ~3~7초
3. KIS API 주문-체결: ~1~3초

**시장가 주문의 치명적 단점**:
- 모멘텀 시그널 = 가격 급등 중 → 매도 호가가 급속히 올라감
- 시장가는 최선 매도호가에 체결 → 시그널 가격 대비 +1~5% 불리
- 결과: 텔레그램에 +5% 표시 → 앱에서 -2~-3% 확인

### 제안하는 개선 방안 (검토 요청)

**방안 1: Pullback Entry (눌림목 진입)**
- 모멘텀 시그널 발생 시 즉시 매수하지 않고 대기
- 직전 고가 대비 -1~-2% 조정 시 진입
- 장점: 상투 회피, 단점: 강한 모멘텀 놓칠 수 있음

**방안 2: 지정가 주문 (Limit Order)**
- 시장가 대신 시그널 가격 +0.3% 이내 지정가
- 10초 이내 미체결 시 자동 취소
- 장점: 슬리피지 제거, 단점: 체결 실패율 증가

**방안 3: 1분봉→틱 기반 전환**
- 봉 완성을 기다리지 않고 틱 단위로 조건 체크
- 조건 충족 즉시 시그널 발행
- 장점: 30초 지연 제거, 단점: 노이즈 증가, 가짜 시그널 증가 위험

**방안 4: 확인(Confirmation) 기간 추가**
- 모멘텀 조건 충족 후 다음 봉에서 추세 유지 확인
- 2번째 봉에서도 상승 유지 시에만 매수
- 장점: 가짜 돌파 필터링, 단점: 추가 지연

**방안 5: 모멘텀 전략 자체의 재설계**
- 초단기(분봉) 모멘텀을 퀀트 관점의 중기 모멘텀으로 전환
- Scout의 Quant Scorer v2가 이미 6개월 모멘텀을 평가중
- 분봉 모멘텀은 제거하고, 눌림목(DIP_BUY, BULL_PULLBACK) 위주로 전환
- 장점: 학술적으로 검증된 접근, 단점: 초단기 기회 포기

### 참고: 이번 주 실전 성과

이번 주 매매 26건 전부 수익 (승률 100%, +10.3M원). 다만 모멘텀으로 들어간 종목 중 일부는 불필요한 손실을 겪고 회복된 경우가 있었음.

### 질문

1. 위 5개 방안 중 어떤 조합이 최적인가?
2. 단기적으로 가장 효과적이면서 리스크가 낮은 변경은?
3. 현재 100% 승률을 유지 중인데, 기존 로직을 건드리는 것이 합리적인가?
4. 구현 우선순위와 단계적 롤아웃 전략은?

- Target: None

# Final Plan: 모멘텀 전략 상투 잡기 문제 해결

---

## 1. 승인된 범위 (Approved Scope)

### 포함 사항
- **지정가 주문 도입** (방안2): `buy-executor` 수정으로 시장가 → 지정가 전환
- **확인 기간 추가** (방안4): `opportunity_watcher.py`에 1봉 확인 로직 추가
- **강화된 모니터링**: 슬리피지 및 엔드투엔드 지연 메트릭 추적
- **단계적 카나리아 배포**: 1주일 A/B 테스트 (20% 신규 로직, 80% 기존)

### 제외 사항
- 틱 기반 전환 (방안3): 노이즈 증가 및 복잡도 과다
- 전략 재설계 (방안5): 현재 100% 승률 기반 훼손 위험
- Pullback Entry 단독 도입 (방안1): 2차 실험으로 보류

### 근거
- 제니/민지 분석 일치: 지연(~30초) + 시장가 주문의 "이중 타격"이 핵심 원인
- 준호 판정: 신호 품질은 우수(100% 승률), **실행 파이프라인만 최적화** 필요
- 보수적 접근: 전략 로직 미변경, 설정 및 실행 로직만 개선

---

## 2. 실행 순서 (Action Steps)

### Step 1️⃣: 모니터링 인프라 구축 (즉시, 병렬)
**담당**: 개발팀  
**소요시간**: 2~3일

- 모든 주문에 대해 다음 메트릭 로깅:
  - **슬리피지**: `(체결가 - 신호가) / 신호가 × 100%`
  - **엔드투엔드 지연**: 신호 생성 → 주문 체결 시간
  - **신호 발생 시간**: 시그널 기준 가격 타임스탐프
  
- 실시간 대시보드에 표시:
  - 일일 평균 슬리피지
  - 체결률 (%)
  - 신호 발생 빈도

**롤백**: 없음 (읽기 전용)

---

### Step 2️⃣: 지정가 주문 도입 (우선순위 1)
**담당**: 개발팀  
**소요시간**: 3~4일  
**파일**: `buy-executor.py` (또는 주문 생성 함수)

**변경 내용**:
```python
STRATEGY_LIMIT_ORDER_CONFIG = {
    'MOMENTUM': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},
    'MOMENTUM_CONTINUATION_BULL': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},
    'SHORT_TERM_HIGH_BREAKOUT': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},
    'VCP_BREAKOUT': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},
    'DEFAULT': {'enabled': False}  # 다른 전략은 시장가 유지
}

def execute_buy_order(signal_data):
    strategy = signal_data.get('strategy_name')
    signal_price = signal_data.get('price')
    config = STRATEGY_LIMIT_ORDER_CONFIG.get(strategy, STRATEGY_LIMIT_ORDER_CONFIG['DEFAULT'])
    
    if config['enabled']:
        limit_price = round(signal_price * (1 + config['premium']), 0)
        order_type = 'limit'
        # 10초 후 미체결 시 자동 취소 로직 추가
    else:
        order_type = 'market'
    
    # KIS API 호출 및 로깅
```

**예상 효과**:
- 슬리피지: 현재 +1~5% → 목표 ±0.5% 이내
- 체결률: 85~95% (모멘텀 강도에 따라 변동)

**롤백 조건** (즉시 실행):
```
IF (1주일 내 모멘텀 체결률 < 70%)
  AND (총 포착 기회 수익 < 기존 대비 15%)
THEN config['enabled'] = False
```

---

### Step 3️⃣: 확인 기간 로직 추가 (우선순위 2)
**담당**: 개발팀  
**소요시간**: 3~4일  
**파일**: `opportunity_watcher.py` 내 모멘텀 전략 클래스

**변경 내용**:
```python
class MomentumStrategy(BaseStrategy):
    def __init__(self, config):
        super().__init__(config)
        self.confirmation_bars = config.get('confirmation_bars', 0)  # 기본값 0
        self.pending_signals = {}  # {symbol: signal_data}
    
    def evaluate(self, symbol, bar_data):
        if self._check_momentum_condition(symbol, bar_data):
            if self.confirmation_bars > 0:
                # 신호를 대기열에 저장 (다음 봉 확인 대기)
                self.pending_signals[symbol] = {
                    'signal_data': self._create_signal_data(symbol, bar_data),
                    'bars_remaining': self.confirmation_bars,
                    'initial_price': bar_data['close']
                }
                return None
            else:
                return self.generate_signal(symbol, 'BUY', bar_data['close'])
        
        # 대기 중인 신호 처리
        if symbol in self.pending_signals:
            pending = self.pending_signals[symbol]
            if bar_data['close'] > pending['initial_price']:  # 상승 유지 확인
                pending['bars_remaining'] -= 1
                if pending['bars_remaining'] <= 0:
                    final_signal = self.generate_signal(symbol, 'BUY', bar_data['close'])
                    del self.pending_signals[symbol]
                    return final_signal
            else:
                del self.pending_signals[symbol]  # 신호 폐기
        
        return None
```

**설정** (config.yaml):
```yaml
strategies:
  momentum:
    confirmation_bars: 1  # 1봉 확인 (0 = 비활성화)
```

**예상 효과**:
- 신호 발생 빈도: ~20~30% 감소
- 승률: 100% 유지 또는 소폭 상승
- 추가 지연: ~60초

**롤백 조건** (즉시 실행):
```
IF (1주일 내 신호 발생 빈도 > 50% 감소)
  AND (평균 수익률 < 기존 대비 20%)
THEN confirmation_bars = 0
```

---

### Step 4️⃣: 카나리아 배포 및 A/B 테스트 (1주일)
**담당**: 개발팀 + 운영팀  
**소요시간**: 7일

**배포 전략**:
- **Group A (80%)**: 기존 로직 (시장가 + 확인 기간 없음)
- **Group B (20%)**: 신규 로직 (지정가 +0.3% + 1봉 확인)

**신호 라우팅**:
```python
def route_signal(signal_data):
    if random.random() < 0.2:  # 20%
        return execute_with_new_logic(signal_data)  # Group B
    else:
        return execute_with_old_logic(signal_data)  # Group A
```

**성공 지표**:
- Group B 평균 슬리피지 ≤ 0.5%
- Group B 승률 ≥ 80%
- Group B 총 수익률이 Group A 대비 10% 이상 하락하지 않음

**모니터링 주기**: 매일 오전 10시 리뷰

---

### Step 5️⃣: 결과 분석 및 의사결정 (1주일 후)
**담당**: 분석팀 + 의사결정자  
**소요시간**: 1~2일

**분석 항목**:
| 지표 | Group A | Group B | 판정 |
|------|---------|---------|------|
| 평균 슬리피지 | ? | ≤0.5% | ✅ |
| 승률 | 100% | ≥80% | ✅ |
| 체결률 | 100% | ≥70% | ✅ |
| 총 수익 | 기준 | 기준 ±10% | ✅ |

**의사결정**:
- ✅ 모든 지표 통과 → **Step 6으로 진행**
- ⚠️ 일부 지표 미달 → **설정 조정 후 재테스트** (premium 0.002로 낮추기 등)
- ❌ 주요 지표 실패 → **롤백 및 2차 실험 계획**

---

### Step 6️⃣: 전사 배포 (점진적)
**담당**: 개발팀 + 운영팀  
**소요시간**: 3~5일

**배포 단계**:
1. **Day 1**: 50% 트래픽 → 신규 로직
2. **Day 2**: 75% 트래픽 → 신규 로직
3. **Day 3**: 100% 트래픽 → 신규 로직

**롤백 트리거** (언제든 실행 가능):
```
IF (일일 최대 손실 > 초기 자본의 5%)
  OR (체결률 < 70% 지속)
  OR (슬리피지 > 1% 지속)
THEN immediate_rollback()
```

---

### Step 7️⃣: 모니터링 및 최적화 (지속)
**담당**: 운영팀  
**주기**: 주 1회 리뷰

**추적 항목**:
- 일일/주간 슬리피지 추이
- 신호 발생 빈도 및 승률
- 지정가 프리미엄 최적화 (0.3% → 0.2% 또는 0.4% 조정)
- 확인 기간 효과 (1봉 → 2봉 확대 검토)

---

## 3. 실험 (Experiments) 및 수용 기준 (Acceptance Criteria)

### 실험 1: 지정가 주문 + 확인 기간 결합
**가설**: "지정가 주문(+0.3%)과 1봉 확인 기간을 결합하면, 슬리피지를 제거하면서도 가짜 신호를 필터링할 수 있다."

**방법**: 카나리아 배포 (Group A vs Group B, 1주일)

**성공 기준**:
- ✅ Group B 평균 슬리피지 ≤ 0.5% (현재 +1~5% → 90% 개선)
- ✅ Group B 승률 ≥ 80% (현재 100% 유지 또는 소폭 하락 허용)
- ✅ Group B 체결률 ≥ 70% (지정가 미체결 리스크 관리)
- ✅ Group B 총 수익 ≥ Group A 대비 85% (슬리피지 감소로 상쇄)

**실패 기준** (즉시 롤백):
- ❌ 체결률 < 70% (기회 손실 과다)
- ❌ 승률 < 70% (신호 품질 악화)
- ❌ 총 수익 < Group A 대비 70% (경제성 상실)

---

### 실험 2: 지정가 프리미엄 최적화 (2차, 필요시)
**가설**: "프리미엄을 0.3%에서 0.2%로 낮추면 체결률을 높일 수 있다."

**방법**: 1주일 추가 테스트 (premium 0.2% vs 0.3%)

**성공 기준**:
- ✅ 체결률 ≥ 80% (0.3%보다 5% 이상 향상)
- ✅ 슬리피지 ≤ 0.3% (여전히 우수)

---

### 실험 3: 확인 기간 확대 (2차, 필요시)
**가설**: "확인 기간을 1봉에서 2봉으로 확대하면 가짜 신호를 더 효과적으로 필터링할 수 있다."

**방법**: 1주일 추가 테스트 (confirmation_bars 1 vs 2)

**성공 기준**:
- ✅ 승률 ≥ 85% (가짜 신호 제거)
- ✅ 신호 발생 빈도 ≥ 기존 대비 50% (기회 손실 최소화)

---

## 4. 리스크 및 롤백 트리거 (Risk & Rollback Triggers)

### 주요 리스크

| 리스크 | 심각도 | 설명 | 대응 |
|--------|--------|------|------|
| **체결 실패율 증가** | 🔴 높음 | 지정가 +0.3%로 설정 시 급등 모멘텀에서 미체결 | 프리미엄 0.2%로 낮추기 |
| **추가 지연으로 인한 기회 손실** | 🟡 중간 | 1봉 확인으로 ~60초 추가 지연 | 확인 기간 비활성화 |
| **상태 관리 버그** | 🟡 중간 | pending_signals 로직이 다른 전략과 충돌

---
## Appendix: Raw JSON Outputs
<details><summary>Click to expand</summary>

### Jennie (DeepSeek v3.2)
```json
{
  "text": "## Verdict\n- decision: approve_with_changes\n- confidence: 75\n- scope: 모멘텀 전략의 실행 지연 및 슬리피지 문제 해결을 위한 전략적 조정. 코드 변경보다는 설정, 주문 방식, 전략 혼합에 초점.\n\n## Key Findings (<=5)\n1. **핵심 문제는 \"지연된 시그널 + 시장가 주문\"의 조합**입니다. 1분봉 완성 대기(최대 60초)는 모멘텀 초반을 놓치게 하고, 시장가 주문은 이미 상승한 가격에 불리하게 진입하게 만듭니다.\n2. **100% 승률은 위험 신호일 수 있습니다**. 이는 과도한 필터링(예: LLM 점수 ≥65)으로 인해 매우 적은 수의 \"완벽한\" 기회만 포착하고 있음을 시사하며, 이는 많은 기회를 놓치고 있음을 의미합니다.\n3. **\"상투 잡기\"는 전략 설계 오류보다는 실행 시스템의 구조적 문제**에서 비롯된 것으로 보입니다. 증거(실제 로그)가 없어 정확한 원인은 단정할 수 없으나, 지연과 슬리피지가 주요 원인으로 추정됩니다.\n4. **제안된 방안들은 상호 배타적이지 않으며, 혼합 적용이 가능합니다**. 예: 지정가 주문(방안2) + 확인 기간(방안4) 또는 Pullback Entry(방안1) + 중기 모멘텀 필터(방안5).\n5. **가장 보수적이고 리스크가 낮은 변경은 주문 실행 로직의 변경(방안2)**입니다. 전략 로직을 건드리지 않고 슬리피지만 제어할 수 있습니다.\n\n## Evidence\n- references: (제공된 설명에 기반)\n    - `opportunity_watcher.py` 내 `MOMENTUM`, `MOMENTUM_CONTINUATION_BULL` 등 전략 로직.\n    - 실행 흐름: `BarAggregator` -> 완성된 1분봉 -> 시그널 평가 -> `RabbitMQ` -> `buy-executor` -> KIS API 시장가 주문.\n    - 성과 메트릭: \"이번 주 매매 26건 전부 수익 (승률 100%, +10.3M원)\".\n- missing_data:\n    - 구체적인 백테스트 결과와 실전 로그(특히 시그널 발생 시간 vs 주문 체결 시간 vs 체결 가격 비교).\n    - 각 모멘텀 전략별 발생 빈도, 승률, 평균 수익/손실.\n    - `buy-executor`의 주문 처리부터 KIS API 응답까지의 상세 지연 분포 데이터.\n    - 현재 활성화된 Veto 로직과 그 트리거 빈도. (과도한 필터링을 확인할 수 없음)\n\n## Risks & Veto Triggers\n- risks:\n    - **거짓 안전감**: 100% 승률은 샘플 수(26건)가 적거나, 시장 조건이 특수할 수 있어 지속 가능하지 않을 위험이 큽니다.\n    - **체결 실패 리스크**: 지정가 주문 도입 시, 빠른 모멘텀에서 주문이 체결되지 못해 기회를 완전히 놓칠 수 있습니다.\n    - **복잡성 증가**: 너무 많은 방안을 동시에 도입하면 시스템 동작을 추적하고 디버깅하기 어려워집니다.\n- veto_if:\n    - 지정가 주문 도입 후, **체결률이 70% 미만으로 떨어지면서 포착된 기회의 총 기대수익이 감소하는 경우**.\n    - 틱 기반 전환(방안3) 시, **가짜 시그널 노이즈로 인해 거래 비용(수수료, 슬리피지)이 수익을 초과하는 경우**.\n\n## Recommendations\n- immediate_actions:\n    1. **지정가 주문으로의 점진적 전환 (방안2 우선)**:\n        - `buy-executor`를 수정하여, 모멘텀 전략의 매수 시그널에 대해 `current_price * 1.003` (또는 동적 계산) 가격으로 지정가 주문을 발송하도록 변경.\n        - 미체결 시간 제한(예: 10초)과 자동 취소 로직을 반드시 구현.\n    2. **확인 기간 필터 추가 실험 (방안4)**:\n        - `opportunity_watcher.py`의 모멘텀 전략에 `confirmation_bars=1` 파라미터를 도입. 시그널 발생 후 다음 1분봉도 양봉/상승 시에만 최종 시그널을 발행하도록 설정 변경.\n    3. **모니터링 강화**:\n        - 모든 거래에 대해 `(체결가 - 시그널가) / 시그널가` 를 계산하는 \"슬리피지 메트릭\"을 실시간 대시보드에 추가.\n        - 시그널 발생부터 주문 체결까지의 `end-to-end 지연`을 로깅하고 분포를 관찰.\n- experiments:\n    - **가설**: \"지정가 주문(+0.3%)과 1봉 확인 기간을 결합하면, 슬리피지를 제거하면서도 가짜 돌파로 인한 손실을 줄일 수 있다.\"\n    - **방법**: A/B 테스트. 기존 로직(Group A) vs 새로운 로직(지정가+확인기간, Group B)을 50/50 비율로 2주간 병행 실행. 동일한 시그널에 대해 두 그룹의 최종 수익률을 비교.\n    - **성공 지표**: Group B의 평균 슬리피지가 0%에 근접, 승률이 80% 이상 유지, 최종 수익률(슬리피지 제외)이 Group A 대비 하락하지 않음.\n- if_code_change_needed:\n    - `buy-executor`의 주문 생성 로직 변경 (시장가 -> 지정가 로직).\n    - `opportunity_watcher.py`의 전략 평가 함수에 `require_confirmation` 플래그 및 관련 로직 추가.\n    - *(Minji에게 전달할 상세 내용)*: `order_type`을 config에서 전략별로 설정 가능하게 하고, 지정가 계산 로직(`signal_price * (1 + strategy_config['limit_order_premium']`)을 구현하라. 확인 기간 로직은 새로운 봉이 생성될 때 이전 봉의 시그널을 재평가하는 방식으로 구현하라.\n\n## Questions to the User (optional, <=3)\n1. 현재 100% 승률을 기록한 26건의 거래에서, 평균 \"체결가와 시그널 발생 시점의 가격 차이(슬리피지)\"는 얼마였나요? 이 수치가 전략의 실제 수익성을 가리는 주요 요소인가요?\n2. `opportunity_watcher.py`에서 현재 어떤 Veto 로직(예: 최대 손실률, 변동성 제한, LLM 점수 하한)이 활성화되어 있으며, 이들이 시그널 발생 건수를 얼마나 제한하고 있나요?\n3. Scout의 `Quant Scorer v2`(6개월 모멘텀) 점수와 현재 분봉 모멘텀 시그널 간의 상관관계를 분석한 데이터가 있나요? 중기 모멘텀 강한 종목에서 단기 모멘텀 진입이 더 효과적일 수 있는지 검증이 필요합니다.",
  "decision": "neutral",
  "raw_output": true
}
```
### Minji (DeepSeek v3.2)
```json
{
  "text": "## Verdict\n- decision: approve_with_changes\n- confidence: 85\n- scope: 모멘텀 전략의 실행 지연 및 슬리피지 문제 해결을 위한 최소 범위 코드 변경. `buy-executor`의 주문 로직 수정(시장가→지정가) 및 `opportunity_watcher.py`에 확인 기간 옵션 추가.\n\n## Key Findings (<=5)\n1. **핵심 문제는 실행 파이프라인의 구조적 지연과 시장가 주문의 불리함 결합**입니다. 1분봉 완성 대기(~30초) + 처리 지연(~10초)으로 인해 시그널이 이미 과거의 가격을 기반으로 하며, 시장가 주문은 그 사이 상승한 가격에 체결됩니다.\n2. **100% 승률은 샘플 크기(26건)와 특정 시장 조건에 기인한 위험한 지표**일 수 있습니다. 이는 시스템이 \"완벽한\" 기회만 포착하고 있음을 의미하며, 많은 기회를 놓치거나 슬리피지로 인한 수익을 잠식하고 있을 수 있습니다.\n3. **제니의 분석과 권장사항(지정가 주문 + 확인 기간)은 타당하며, 최소한의 코드 변경으로 시험 가능**합니다. 이는 전략 로직의 대대적인 수정보다 안전합니다.\n4. **구현은 점진적이고 측정 가능한 방식으로 진행해야 합니다**. A/B 테스트 또는 카나리아 배포를 통해 새로운 로직의 성과를 정량적으로 비교하고, 리스크를 제어할 수 있습니다.\n5. **롤백 계획이 명확해야 합니다**. 새로운 로직이 체결률 저하나 수익 감소로 이어진다면 즉시 기존 로직으로 복귀할 수 있어야 합니다.\n\n## Evidence\n- references:\n    - (추정) 실행 파이프라인: `BarAggregator` -> `opportunity_watcher.py` -> `RabbitMQ` -> `buy-executor` -> KIS API.\n    - (추정) 전략 로직: `opportunity_watcher.py` 내 `MOMENTUM`, `MOMENTUM_CONTINUATION_BULL` 등.\n    - 성과 메트릭: \"이번 주 매매 26건 전부 수익 (승률 100%, +10.3M원)\".\n- missing_data:\n    - 정확한 파일 경로와 함수명 (예: `buy-executor`의 주문 생성 함수).\n    - 현재 `buy-executor`의 설정(config) 구조.\n    - 슬리피지와 엔드투엔드 지연에 대한 상세 로그 데이터.\n\n## Risks & Veto Triggers\n- risks:\n    - **체결 실패 리스크**: 지정가 주문 도입 시 빠른 모멘텀에서 주문이 체결되지 못해 기회를 완전히 놓칠 수 있습니다.\n    - **복잡성 증가**: 확인 기간 로직이 실시간 바 처리 로직에 새로운 상태 관리 부담을 줄 수 있습니다.\n    - **예상치 못한 상호작용**: 새로운 로직이 기존 다른 전략(예: 눌림목 매수)과 충돌할 수 있습니다.\n- veto_if:\n    - **체결률 저하**: 지정가 주문 도입 후, 모멘텀 전략의 주문 체결률이 70% 미만으로 떨어지면서 총 수익 기회가 감소하는 경우.\n    - **성능 저하**: 확인 기간 로직으로 인해 시스템 처리량이 현저히 떨어지거나 지연이 증가하는 경우.\n\n## Recommendations\n- immediate_actions:\n    1. **`buy-executor` 수정: 모멘텀 전략에 한해 지정가 주문 도입**.\n        - 변경점: 모멘텀 전략(`strategy_name` 포함 `MOMENTUM`)에서 발생한 매수 시그널에 대해, `current_price * (1 + premium)` 가격으로 지정가 주문 발송. `premium`은 설정 가능(초기값 0.003).\n        - 미체결 주문은 10초 후 자동 취소.\n    2. **`opportunity_watcher.py` 수정: 확인 기간(Confirmation) 옵션 추가**.\n        - 변경점: 모멘텀 전략 클래스에 `confirmation_bars=1` 파라미터를 추가. 시그널 발생 후, 다음 N개의 바가 추가 조건(예: 종가 상승)을 만족할 때만 최종 시그널을 발행.\n    3. **강화된 모니터링 배포**:\n        - 모든 거래에 대해 `(체결가 - 시그널_기준가) / 시그널_기준가` 슬리피지 메트릭을 계산하여 로깅 및 대시보드 표시.\n        - 시그널 생성 타임스탬프부터 주문 체결 타임스탬프까지의 지연을 측정.\n- experiments:\n    - **가설**: \"지정가 주문(+0.3%)과 1봉 확인 기간을 결합하면, 슬리피지를 제어하면서도 승률을 유지할 수 있다.\"\n    - **방법**: 카나리아 배포. 트래픽의 20%를 새로운 로직(Group B)으로 라우팅, 80%는 기존 로직(Group A) 유지. 1주간 실행.\n    - **성공 지표**: Group B의 평균 슬리피지 ≤ 0.5%, 승률 ≥ 80%, 총 수익률(슬리피지 제외)이 Group A 대비 10% 이상 하락하지 않음.\n- if_code_change_needed:\n    ```diff\n    # File: executors/buy_executor.py (가정된 경로)\n    # 함수: execute_buy_order(signal_data)\n    \n    + STRATEGY_LIMIT_ORDER_CONFIG = {\n    +     'MOMENTUM': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},\n    +     'MOMENTUM_CONTINUATION_BULL': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},\n    +     'SHORT_TERM_HIGH_BREAKOUT': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},\n    +     'VCP_BREAKOUT': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},\n    +     # 다른 전략은 기본값(시장가) 유지\n    +     'DEFAULT': {'enabled': False}\n    + }\n    \n    def execute_buy_order(signal_data):\n        strategy = signal_data.get('strategy_name')\n        base_price = signal_data.get('price')  # 시그널 기준 가격\n        config = STRATEGY_LIMIT_ORDER_CONFIG.get(strategy, STRATEGY_LIMIT_ORDER_CONFIG['DEFAULT'])\n        \n    -   # 기존 시장가 주문 로직\n    -   order_params = {'order_type': 'market', 'price': 0}\n    +   if config['enabled']:\n    +       limit_price = round(base_price * (1 + config['premium']), 2)  # 원화 단위 조정 필요\n    +       order_params = {'order_type': 'limit', 'price': limit_price}\n    +       # 주문 발송 후, config['timeout_sec'] 내 미체결 시 취소하는 백그라운드 태스크 시작\n    +   else:\n    +       order_params = {'order_type': 'market', 'price': 0}\n        \n        # ... 기존 KIS API 호출 로직 ...\n    ```\n    ```diff\n    # File: strategies/opportunity_watcher.py (가정된 경로)\n    # 모멘텀 전략 클래스 내부\n    \n    class MomentumStrategy(BaseStrategy):\n    -   def __init__(self, config):\n    +   def __init__(self, config):\n            super().__init__(config)\n    +       self.confirmation_bars = config.get('confirmation_bars', 0)\n    +       self.pending_signals = {}  # {symbol: [signal_data, remaining_bars]}\n    \n    -   def evaluate(self, symbol, data):\n    +   def evaluate(self, symbol, data):\n            # 기존 모멘텀 조건 평가 로직\n            if momentum_condition_met:\n    -           return self.generate_signal(symbol, 'BUY', data['close'])\n    +           if self.confirmation_bars > 0:\n    +               # 확인 기간 필요: 신호를 대기열에 저장\n    +               self.pending_signals[symbol] = [self._create_signal_data(symbol, data), self.confirmation_bars]\n    +               return None\n    +           else:\n    +               return self.generate_signal(symbol, 'BUY', data['close'])\n    +   \n    +   def on_new_bar(self, symbol, data):\n    +       \"\"\"새로운 바가 생성될 때마다 호출하여 확인 기간 대기 신호 처리\"\"\"\n    +       if symbol in self.pending_signals:\n    +           signal_data, bars_left = self.pending_signals[symbol]\n    +           if self._confirmation_condition_met(data): # 예: data['close'] > signal_data['price']\n    +               bars_left -= 1\n    +               if bars_left <= 0:\n    +                   # 확인 완료: 최종 신호 발행\n    +                   final_signal = self.generate_signal(symbol, 'BUY', data['close'])\n    +                   del self.pending_signals[symbol]\n    +                   return final_signal\n    +               else:\n    +                   self.pending_signals[symbol][1] = bars_left\n    +           else:\n    +               # 확인 조건 실패: 신호 폐기\n    +               del self.pending_signals[symbol]\n    +       return None\n    ```\n\n## Questions to the User (optional, <=3)\n1. `buy-executor`의 정확한 파일 경로와 주문을 생성하는 주요 함수의 이름을 알려주실 수 있나요? 또한, 현재 주문 유형(시장가/지정가)을 결정하는 설정(config) 구조가 어떻게 되어 있나요?\n2. `opportunity_watcher.py`에서 서로 다른 전략(모멘텀, 눌림목 등)을 구분하는 키(예: `strategy_name`)가 시그널 데이터에 포함되어 `buy-executor`로 전달되나요?\n3. 제안된 코드 변경을 테스트하기 위한 스테이징(테스트) 환경이 구축되어 있나요? 아니면 실거래를 트리거할 수 있는 변경에 대한 안전한 배포 절차(예: 기능 플래그)가 있나요?",
  "error": "JSON Parse Failed: Expecting property name enclosed in double quotes: line 2 column 5 (char 6)",
  "raw_json_snippet": "{\n    +     'MOMENTUM': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},\n    +     'MOMENTUM_CONTINUATION_BULL': {'enabled': True, 'premium': 0.003, 'timeout_sec': 10},\n    +     'SHORT_TERM_HI"
}
```
### Junho (Claude Opus 4.6)
```json
{
  "text": "# Council Output: 모멘텀 전략 상투 잡기 문제 최종 판정\n\n---\n\n## Verdict\n\n- **decision**: `approve_with_changes`\n- **confidence**: `82`\n- **scope**: \n  - **포함**: 지정가 주문(방안2) + 확인 기간(방안4) 결합 구현 / 강화된 모니터링 / 단계적 카나리아 배포\n  - **제외**: 틱 기반 전환(방안3) / 전략 재설계(방안5) / Pullback Entry 단독 도입(방안1)\n  - **보류**: 방안1은 방안2/4 성과 검증 후 2차 실험으로 고려\n\n---\n\n## Key Findings (<=5)\n\n1. **지연 + 시장가 주문의 \"이중 타격\" 구조가 핵심 원인**\n   - 1분봉 완성 대기(~30초) + 처리(~5초) = 신호가 이미 과거 가격 기반\n   - 시장가 주문은 그 사이 상승한 최선 매도호가에 체결 → +1~5% 슬리피지\n   - 결과: 텔레그램 수익 vs 실제 수익의 괴리 발생\n\n2. **100% 승률(26건)은 \"위험한 신호\"이자 \"기회\"**\n   - 위험: 샘플 크기 부족 + 특수 시장 조건 + 과도한 필터링(LLM≥65)으로 인한 거짓 안전감\n   - 기회: 현재 시스템이 \"좋은 신호\"를 잘 포착하고 있다는 증거 → 실행만 개선하면 더 나아질 여지 있음\n   - **결론**: 전략 로직은 건드리지 말고, 실행 파이프라인만 최적화\n\n3. **제니 vs 민지의 분석이 본질적으로 일치**\n   - 제니: 전략적 관점에서 \"지정가+확인기간\" 권장 (75% 신뢰도)\n   - 민지: 구현 관점에서 동일 방안 + 구체적 코드 제시 (85% 신뢰도)\n   - 차이: 민지가 더 구체적이고 실행 가능한 형태로 제시 → 민지 제안을 기반으로 진행\n\n4. **방안2(지정가)와 방안4(확인기간)는 상호 보완적**\n   - 지정가: 슬리피지 제거 (가격 리스크 감소)\n   - 확인기간: 가짜 신호 필터링 (신호 품질 향상)\n   - 결합 효과: 체결률 저하 리스크를 신호 품질 향상으로 상쇄 가능\n\n5. **방안3(틱 기반)과 방안5(전략 재설계)는 현 단계에서 과도**\n   - 방안3: 노이즈 증가 + 시스템 복잡도 급증 → 검증 비용 높음\n   - 방안5: 초단기 기회 포기 + 전략 로직 대대적 수정 → 현재 100% 승률 기반 훼손 위험\n   - **결론**: 방안2/4 성과 검증 후 필요시 2차 실험으로 고려\n\n---\n\n## Evidence\n\n### References\n- **Jennie의 분석**: 지연 누적(30~90초) + 시장가 주문의 슬리피지 메커니즘 정확히 파악\n- **Minji의 제안**: 구체적 코드 변경점(buy-executor, opportunity_watcher.py) + 설정 구조 제시\n- **실전 성과**: 26건 100% 승률, +10.3M원 (신호 품질 우수 증거)\n- **Missing Data** (중요):\n  - 실제 슬리피지 분포 데이터 (평균 몇 %인가?)\n  - 시그널 발생 시간 vs 체결 시간 vs 체결 가격의 상세 로그\n  - 현재 활성화된 Veto 로직(LLM≥65 등)이 신호를 얼마나 필터링하는가?\n  - 방안2 도입 시 예상 체결률 (민지 제안에서 \"70% 미만 시 veto\" 기준)\n\n---\n\n## Risks & Veto Triggers\n\n### Risks\n\n| 위험 요소 | 심각도 | 설명 |\n|---------|--------|------|\n| **체결 실패율 증가** | 🔴 높음 | 지정가 +0.3%로 설정 시, 급등 모멘텀에서 주문이 체결되지 못할 수 있음 → 기회 손실 |\n| **확인 기간으로 인한 추가 지연** | 🟡 중간 | 1봉 확인 추가 시 ~60초 추가 지연 → 강한 모멘텀 놓칠 수 있음 |\n| **상호작용 버그** | 🟡 중간 | 새로운 상태 관리(pending_signals) 로직이 다른 전략(눌림목 등)과 충돌 가능 |\n| **거짓 안전감 지속** | 🟡 중간 | 100% 승률에 안주하여 근본적 개선 미루기 |\n| **설정 복잡도 증가** | 🟢 낮음 | 전략별 지정가 프리미엄 설정 필요 → 관리 부담 증가 |\n\n### Veto Triggers (즉시 롤백 조건)\n\n```\nIF (지정가 도입 후 1주일 내)\n  AND (모멘텀 전략 체결률 < 70%)\n  AND (총 포착 기회 수익 < 기존 대비 15%)\nTHEN veto_and_rollback()\n\nIF (확인 기간 도입 후 1주일 내)\n  AND (신호 발생 빈도 > 50% 감소)\n  AND (평균 수익률 < 기존 대비 20%)\nTHEN veto_and_rollback()\n\nIF (A/B 테스트 중)\n  AND (Group B 최대 손실 > 초기 자본의 5%)\nTHEN immediate_stop_and_rollback()\n```\n\n---\n\n## Recommendations\n\n### Immediate Actions (우선순위 순)\n\n#### 1️⃣ **지정가 주문 도입 (방안2) — 우선순위 1**\n\n**변경 대상**: `buy-executor.py` (또는 해당 주문 생성 함수)\n\n**구체적 변경**:\n```python\n# 설정 추가 (config.yaml 또는 환경변수)\nSTRATEGY_LIMIT_ORDER_CONFIG = {\n    'MOMENTUM': {\n        'enabled': True,\n        'premium': 0.003,  # +0.3% (조정 가능)\n        'timeout_sec': 10\n    },\n    'MOMENTUM_CONTINUATION_BULL': {\n        'enabled': True,\n        'premium': 0.003,\n        'timeout_sec': 10\n    },\n    'SHORT_TERM_HIGH_BREAKOUT': {\n        'enabled': True,\n        'premium': 0.003,\n        'timeout_sec': 10\n    },\n    'VCP_BREAKOUT': {\n        'enabled': True,\n        'premium': 0.003,\n        'timeout_sec': 10\n    },\n    'DEFAULT': {'enabled': False}  # 다른 전략은 시장가 유지\n}\n\ndef execute_buy_order(signal_data):\n    strategy_name = signal_data.get('strategy_name')\n    signal_price = signal_data.get('price')  # 시그널 기준 가격\n    config = STRATEGY_LIMIT_ORDER_CONFIG.get(strategy_name, STRATEGY_LIMIT_ORDER_CONFIG['DEFAULT'])\n    \n    if config['enabled']:\n        # 지정가 계산 (원화 단위 조정 필요)\n        limit_price = round(signal_price * (1 + config['premium']), 0)\n        order_type = 'limit'\n        order_price = limit_price\n        \n        # 미체결 타임아웃 로직 추가 (별도 스레드/태스크)\n        schedule_order_cancellation(order_id, timeout_sec=config['timeout_sec'])\n    else:\n        order_type = 'market'\n        order_price = 0\n    \n    # KIS API 호출\n    kis_response = kis_api.place_order(\n        order_type=order_type,\n        price=order_price,\n        quantity=signal_data['quantity'],\n        symbol=signal_data['symbol']\n    )\n    \n    # 로깅 (슬리피지 추적용)\n    log_order_execution({\n        'strategy': strategy_name,\n        'signal_price': signal_price,\n        'order_type': order_type,\n        'order_price': order_price,\n        'timestamp': datetime.now(),\n        'order_id': kis_response['order_id']\n    })\n    \n    return kis_response\n```\n\n**예상 효과**:\n- 슬리피지 감소: 현재 +1~5% → 목표 ±0.5% 이내\n- 체결률: 초기 예상 85~95% (모멘텀 강도에 따라 변동)\n\n**롤백 계획**:\n- `STRATEGY_LIMIT_ORDER_CONFIG['MOMENTUM']['enabled'] = False` 로 즉시 비활성화 가능\n\n---\n\n#### 2️⃣ **확인 기간(Confirmation) 추가 (방안4) — 우선순위 2**\n\n**변경 대상**: `opportunity_watcher.py` 내 모멘텀 전략 클래스\n\n**구체적 변경**:\n```python\nclass MomentumStrategy(BaseStrategy):\n    def __init__(self, config):\n        super().__init__(config)\n        self.confirmation_bars = config.get('confirmation_bars', 0)  # 기본값 0 (비활성화)\n        self.pending_signals = {}  # {symbol: {'signal_data': ..., 'bars_remaining': N}}\n    \n    def evaluate(self, symbol, bar_data):\n        \"\"\"매 바마다 호출되는 평가 함수\"\"\"\n        \n        # 기존 모멘텀 조건 체크\n        if self._check_momentum_condition(symbol, bar_data):\n            if self.confirmation_bars > 0:\n                # 확인 기간 필요: 신호를 대기열에 저장\n                self.pending_signals[symbol] = {\n                    'signal_data': self._create_signal_data(symbol, bar_data),\n                    'bars_remaining': self.confirmation_bars,\n                    'initial_price': bar_data['close']\n                }\n                # 로그: 신호 대기 중\n                logger.info(f\"[{symbol}] Momentum signal pending confirmation ({self.confirmation_bars} bars)\")\n                return None  # 아직 신호 발행 안 함\n            else:\n                # 확인 기간 없음: 즉시 신호 발행\n                return self.generate_signal(symbol, 'BUY', bar_data['close'])\n        \n        # 대기 중인 신호 처리\n        if symbol in self.pending_signals:\n            pending = self.pending_signals[symbol]\n            \n            # 확인 조건: 현재 종가 > 신호 기준 가격 (상승 유지)\n            if bar_data['close'] > pending['initial_price']:\n                pending['bars_remaining'] -= 1\n                \n                if pending['bars_remaining'] <= 0:\n                    # 확인 완료: 최종 신호 발행\n                    final_signal = self.generate_signal(\n                        symbol, 'BUY', bar_data['close'],\n                        metadata={'confirmation_completed': True}\n                    )\n                    del self.pending_signals[symbol]\n                    logger.info(f\"[{symbol}] Momentum signal confirmed after {self.confirmation_bars} bars\")\n                    return final_signal\n            else:\n                # 확인 실패: 신호 폐기\n                del self.pending_signals[symbol]\n                logger.info(f\"[{symbol}] Momentum signal rejected (confirmation failed)\")\n        \n        return None\n    \n    def _check_momentum_condition(self, symbol, bar_data):\n        \"\"\"기존 모멘텀 조건 로직 (변경 없음)\"\"\"\n        # ... 기존 코드 ...\n        pass\n    \n    def _create_signal_data(self, symbol, bar_data):\n        \"\"\"신호 데이터 생성\"\"\"\n        return {\n            'symbol': symbol,\n            'price': bar_data['close'],\n            'timestamp': bar_data['timestamp'],\n            'strategy_name': 'MOMENTUM'\n        }\n```\n\n**설정 예시** (config.yaml):\n```yaml\nstrategies:\n  momentum:\n    enabled: true\n    confirmation_bars: 1  # 1봉 확인 (0 = 비활성화)\n    # ... 기존 설정 ...\n```\n\n**예상 효과**:\n- 가짜 신호 필터링: 신호 발생 빈도 ~20~30% 감소 (예상)\n- 승률 향상: 100% 유지 또는 소폭 상승 (가짜 돌파 제거)\n- 추가 지연: ~60초 (1봉 대기)\n\n**롤백 계획**:\n- `confirmation_bars: 0` 으로 즉시 비활성화 가능\n\n---\n\n#### 3️⃣ **강화된 모니터링 배포 — 우선순위 1 (병렬 진행)**\n\n**추가할 메트릭**:\n\n```python\n# 모든 주문 체결 후 기록\ndef log_execution_metrics(order_result, signal_data):\n    \"\"\"\n    슬리피지 및 지연 메트릭 계산 및 로깅\n    \"\"\"\n    signal_price = signal_data['price']\n    filled_price = order_result['filled_price']\n    signal_timestamp = signal_data['timestamp']\n    filled_timestamp = order_result['filled_timestamp']\n    \n    # 슬리피지",
  "error": "JSON Parse Failed: Expecting property name enclosed in double quotes: line 2 column 5 (char 6)",
  "raw_json_snippet": "{\n    'MOMENTUM': {\n        'enabled': True,\n        'premium': 0.003,  # +0.3% (조정 가능)\n        'timeout_sec': 10\n    },\n    'MOMENTUM_CONTINUATION_BULL': {\n        'enabled': True,\n        'premium':"
}
```

</details>

---
## Cost Summary
| Model | Input | Output | Cost (USD) |
|-------|-------|--------|------------|
| Jennie (DeepSeek v3.2) | 0 | 0 | $0.0000 |
| Minji (DeepSeek v3.2) | 2,201 | 1,998 | $0.0028 |
| Junho (Claude Opus 4.6) | 4,366 | 2,600 | $0.2605 |
| Orchestrator (Claude Opus 4.6) | 6,289 | 2,171 | $0.2572 |
| **Total** | - | - | **$0.5204** (≈755원) |
