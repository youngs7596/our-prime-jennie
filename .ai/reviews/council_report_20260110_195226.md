# Prime Council Report
- Date: 2026-01-10 19:54:30
- Query: 현재 E2E 백테스트 시뮬레이터(backtest_scout_e2e.py)가 Factor Score 기반으로 Scout 종목 선정을 시뮬레이션하고 있습니다.

문제점:
- 실제 시스템은 LLM(Hunter/Debate/Judge)이 판단하여 삼전 +45% 수익 달성
- 시뮬레이터는 Factor Score만으로 0.34% 수익 (LLM 판단력 재현 한계)

질문:
1. LLM 판단 이력을 활용하여 백테스트 정확도를 높이는 방법은?
2. DECISION_LEDGER 테이블을 Lookup Table로 활용하는 것이 타당한가?
3. 과거 LLM 결정이 없는 날짜/종목에 대한 Fallback 전략은?
- Target: utilities/backtest_scout_e2e.py

# Final Plan: Scout E2E 백테스트 LLM 판단 통합

## 1) 승인된 범위 (Approved scope)
- `ScoutSimulator`에 `_load_llm_decisions_for_date()` 추가 (LLM 결정 우선 로드)
- `E2EBacktestEngine.run_simulation()` 루프 내 LLM 결정 조회 로직 삽입
- Fallback 우선순위: DECISION_LEDGER → WATCHLIST_HISTORY → FactorScore
- 룩어헤드 방어 및 데이터 불완전성 처리 필수

## 2) 실행 순서가 있는 액션 스텝 (Action Steps)
1. **DECISION_LEDGER 스키마 검증**: 테이블 존재 여부 및 스키마 확인
   - SQL 쿼리 실행하여 컬럼명, 데이터 타입, 데이터 범위 확인
2. **Fallback 우선순위 명시 및 조건부 로드 함수 추가**: 
   - `ScoutSimulator` 클래스에 LLM 결정 로드 함수 추가
   - 우선순위 기반으로 DECISION_LEDGER, WATCHLIST_HISTORY, FactorScore 순으로 로드
3. **E2EBacktestEngine.run_simulation() 내 LLM 결정 통합**: 
   - LLM 결정 우선 로드 후, 시뮬레이션 로직 수정
4. **룩어헤드 방어 로직 구현**: 
   - LLM 결정 생성 시점 검증 로직 추가
5. **데이터 불완전성 처리 전략 수립**: 
   - DECISION_LEDGER의 데이터 커버리지 분석 및 편향 감지 로직 추가
6. **성능 저하 방지 조치**: 
   - 배치 조회 및 인덱스 확인을 통해 성능 최적화
7. **테스트 및 검증**: 
   - 모든 변경 사항에 대한 단위 테스트 및 통합 테스트 수행

## 3) 실험 및 수용 기준 (Experiments & Acceptance criteria)
### 실험 1: DECISION_LEDGER 활용
- **가설**: DECISION_LEDGER의 LLM 결정을 직접 활용하면 백테스트의 수익률이 실제 LLM 시스템의 성과에 근접할 것이다.
- **수용 기준**: 시뮬레이션 총 수익률이 실제 LLM 시스템의 수익률(+45%)에 80% 이상 근접해야 함.

### 실험 2: Fallback 전략 개선
- **가설**: Fallback 우선순위를 명확히 하면 시뮬레이션 결과의 정확도가 향상될 것이다.
- **수용 기준**: WATCHLIST_HISTORY와 FactorScore를 활용한 경우의 수익률이 기존 FactorScore만 사용한 경우보다 20% 이상 향상되어야 함.

## 4) 리스크 및 롤백 트리거 (Risk & rollback triggers)
### 리스크
- **룩어헤드 바이어스**: LLM 결정의 생성 시점이 미래인 경우
- **데이터 불완전성**: DECISION_LEDGER가 모든 종목/날짜를 커버하지 않을 경우
- **스키마 오해석**: DECISION_LEDGER의 스키마가 잘못 해석될 경우
- **성능 저하**: 대량의 LLM 결정 이력을 처리하는 과정에서 성능 저하 발생 가능성

### 롤백 트리거
- DECISION_LEDGER 테이블이 존재하지 않거나 데이터가 부족한 경우 (< 1000건)
- 룩어헤드 방어 로직이 구현되지 않은 경우
- LLM 결정 생성 시점이 미래인 경우

## Notes
- 제니와 민지의 의견은 준호의 결정에 따라 반영되었으며, 이견은 보존되었습니다.

---
## Appendix: Raw JSON Outputs
<details><summary>Click to expand</summary>

### Jennie
```json
{
  "text": "## Verdict\n- decision: approve_with_changes\n- confidence: 95\n- scope: `ScoutSimulator`의 종목 선정 로직, `E2EBacktestEngine`의 `WATCHLIST_HISTORY` 및 매수 결정 로직, 그리고 `DECISION_LEDGER` 테이블 활용 방안.\n\n## Key Findings (<=5)\n1.  **LLM 판단력 재현 한계**: 현재 시뮬레이터는 `FactorScorer`와 `NEWS_SENTIMENT`를 기반으로 `estimated_score`를 계산하여 Scout 종목을 선정합니다. 이는 실제 LLM(Hunter/Debate/Judge) 시스템의 복합적인 판단력을 충분히 재현하지 못하며, 이로 인해 실제 시스템의 +45% 수익률과 시뮬레이터의 +0.34% 수익률 간에 큰 격차가 발생합니다.\n2.  **`WATCHLIST_HISTORY`의 제한적 활용**: `E2EBacktestEngine`은 `use_watchlist_history` 옵션을 통해 `WATCHLIST_HISTORY` 테이블의 스냅샷을 활용할 수 있으나, 이는 주로 `LLM_SCORE`를 `estimated_score`로 사용하는 수준에 머무르며, LLM의 구체적인 판단 로직이나 신호 강도를 직접적으로 반영하기에는 부족할 수 있습니다.\n3.  **`DECISION_LEDGER`의 잠재적 가치**: `DECISION_LEDGER` 테이블은 실제 LLM 시스템의 결정 이력을 담고 있을 가능성이 높으며, 이는 LLM의 판단을 가장 직접적으로 시뮬레이터에 반영할 수 있는 핵심 \"증거\"가 될 수 있습니다. 현재 시뮬레이터는 이 테이블을 활용하지 않고 있습니다.\n4.  **Fallback 전략의 필요성**: LLM 결정 이력이 없는 과거 데이터나 특정 종목에 대해서는 현재의 Factor Score 기반 로직이 유일한 Fallback으로 작동합니다. LLM 데이터의 가용성에 따라 이 Fallback 로직의 중요도가 달라지므로, 명확한 우선순위와 전환 로직이 필요합니다.\n5.  **매수 신호 임계값의 경직성**: `buy_signal_threshold`는 `is_entry` (기술적 신호) 여부에 따라 5점 정도만 조정됩니다. LLM의 판단은 단순 점수 임계값을 넘어선 복합적인 Buy/No-Buy 신호를 포함할 수 있으며, 현재의 점수 기반 필터링이 LLM의 의도를 충분히 반영하지 못할 수 있습니다.\n\n## Evidence\n- references:\n    - `backtest_scout_e2e.py:ScoutSimulator.simulate_scout_for_date`: Factor Score 및 뉴스 감성 기반 `estimated_score` 계산 로직 (Phase B-1)\n    - `backtest_scout_e2e.py:E2EBacktestEngine.run_simulation`: `ScoutSimulator` 호출 및 `use_watchlist_history` 옵션 처리, `buy_signal_threshold` 적용 로직\n    - `backtest_scout_e2e.py:E2EBacktestEngine._load_watchlist_history_snapshot`: `WATCHLIST_HISTORY`에서 `LLM_SCORE`를 로드하는 부분\n    - 사용자 요청: \"실제 시스템은 LLM(Hunter/Debate/Judge)이 판단하여 삼전 +45% 수익 달성, 시뮬레이터는 Factor Score만으로 0.34% 수익\"\n- missing_data:\n    - `DECISION_LEDGER` 테이블의 정확한 스키마 및 예시 데이터: `STOCK_CODE`, `DECISION_DATE`, `LLM_DECISION_TYPE` (e.g., BUY, HOLD, SELL), `LLM_SCORE`, `LLM_CONFIDENCE`, `LLM_REASON` 등 LLM의 최종 판단을 나타내는 필드들이 필요합니다. 이것이 결론을 어떻게 바꿀 수 있는가: LLM의 실제 판단을 직접적으로 시뮬레이션에 반영하여 정확도를 획기적으로 높일 수 있습니다.\n    - `WATCHLIST_HISTORY` 테이블의 정확한 스키마 및 예시 데이터: `LLM_SCORE` 외에 LLM의 다른 판단 지표가 포함되어 있는지 확인이 필요합니다. 이것이 결론을 어떻게 바꿀 수 있는가: `DECISION_LEDGER`가 없을 경우 `WATCHLIST_HISTORY`를 더 상세하게 활용할 수 있습니다.\n    - 실제 LLM(Hunter/Debate/Judge) 시스템의 최종 출력 형식: LLM이 최종적으로 어떤 형태의 \"신호\"를 생성하는지 (예: 점수, 등급, 직접적인 매수/매도 지시) 명확히 알아야 합니다. 이것이 결론을 어떻게 바꿀 수 있는가: 시뮬레이터의 `estimated_score`와 `buy_signal_threshold`를 LLM의 실제 신호에 더 가깝게 매핑할 수 있습니다.\n\n## Risks & Veto Triggers\n- risks:\n    - **룩어헤드(Look-ahead) 방지 실패**: `DECISION_LEDGER` 또는 `WATCHLIST_HISTORY`에서 LLM 결정을 로드할 때, 해당 결정이 시뮬레이션 `target_date` 이전에 생성된 것임을 엄격히 검증해야 합니다. 미래 정보를 사용하여 과거를 시뮬레이션하는 오류를 범할 수 있습니다.\n    - **데이터 불완전성**: `DECISION_LEDGER`에 모든 종목/날짜에 대한 LLM 결정이 없을 경우, 불완전한 데이터로 인해 시뮬레이션 결과가 왜곡되거나 특정 기간/종목에 대한 LLM의 효과를 제대로 측정하지 못할 수 있습니다.\n    - **LLM 결정의 오해석**: LLM의 \"점수\"나 \"결정\"이 시뮬레이터의 `estimated_score`나 `buy_signal_threshold`와 1:1로 매핑되지 않을 경우, LLM의 의도를 잘못 해석하여 시뮬레이션 결과가 실제와 달라질 수 있습니다.\n    - **성능 저하**: 대량의 LLM 결정 이력을 매일 조회하고 처리하는 과정에서 백테스트 속도가 현저히 느려질 수 있습니다.\n- veto_if:\n    - LLM 결정 이력을 로드하는 과정에서 룩어헤드 바이어스 방어 로직이 명확히 구현되지 않거나 검증되지 않을 경우.\n    - `DECISION_LEDGER` 데이터가 너무 불완전하여 LLM의 판단력을 유의미하게 재현할 수 없을 경우.\n\n## Recommendations\n- immediate_actions:\n    1.  **`DECISION_LEDGER` 우선 활용 로직 구현**: `E2EBacktestEngine.run_simulation` 내에서 `ScoutSimulator`를 호출하기 전에, `current_date`에 대한 `DECISION_LEDGER`의 LLM 결정을 먼저 조회하도록 합니다. 만약 해당 종목에 대한 LLM 결정이 존재한다면, 그 결정을 `ScoutSnapshot`의 `hot_watchlist`에 직접 반영하고, 기존 `FactorScorer` 로직은 건너뜁니다.\n    2.  **LLM 결정 매핑 정의**: `DECISION_LEDGER`에서 가져온 LLM의 최종 점수(`LLM_SCORE`) 또는 직접적인 매수 신호(`LLM_DECISION_TYPE = 'BUY'`)를 `ScoutSnapshot`의 `estimated_score` 필드에 매핑하는 규칙을 명확히 정의합니다. 예를 들어, `LLM_DECISION_TYPE = 'BUY'`인 경우 `estimated_score`를 100으로, `HOLD`인 경우 50으로 설정하는 등.\n    3.  **Fallback 로직 명시적 전환**: LLM 결정이 없는 종목/날짜에 대해서는 현재의 `ScoutSimulator` (Factor Score + 뉴스 감성) 로직을 명시적인 Fallback으로 사용하도록 `E2EBacktestEngine`의 `run_simulation` 로직을 수정합니다.\n- experiments:\n    1.  **Hypothesis**: `DECISION_LEDGER`의 LLM 결정을 직접 활용하면 백테스트의 수익률과 거래 패턴이 실제 LLM 시스템의 성과에 근접할 것이다.\n        *   **Method**:\n            *   `E2EBacktestEngine`에 `_load_llm_decisions_for_date(date, codes)` 함수를 추가하여 `DECISION_LEDGER`에서 해당 날짜의 LLM 결정을 조회합니다.\n            *   `run_simulation` 루프 내에서, 각 `current_date`마다 `daily_universe`의 모든 종목에 대해 LLM 결정을 먼저 조회합니다.\n            *   LLM 결정이 있는 종목은 `estimated_score`를 LLM 결정에 따라 설정하고, `hot_watchlist`에 추가합니다.\n            *   LLM 결정이 없는 종목에 대해서만 `scout_sim.simulate_scout_for_date`를 호출하여 `hot_watchlist`를 보완합니다.\n            *   기존 `buy_signal_threshold` 로직을 LLM 결정에 맞게 조정하거나, LLM이 직접 'BUY' 신호를 준 경우 무조건 매수 후보로 간주하도록 변경합니다.\n            *   실제 LLM 시스템이 운영된 기간과 동일한 기간으로 백테스트를 실행합니다.\n        *   **Success metrics**:\n            *   시뮬레이션 총 수익률이 실제 LLM 시스템의 수익률(+45%)에 얼마나 근접하는가.\n            *   시뮬레이션된 매수/매도 종목 및 시점이 실제 LLM 시스템의 거래 로그와 얼마나 일치하는가 (정확도, 재현율).\n            *   최대 낙폭(MDD) 및 샤프 비율 등 리스크 지표의 개선 여부.\n    2.  **Hypothesis**: LLM의 'BUY' 신호에 대한 매수 임계값을 유연하게 적용하면, 시장 국면에 따른 LLM의 판단력을 더 잘 반영할 수 있다.\n        *   **Method**:\n            *   `DECISION_LEDGER`에 `LLM_CONFIDENCE` 필드가 있다면, 이를 활용하여 `buy_signal_threshold`를 동적으로 조절합니다. 예를 들어, `STRONG_BULL` 국면에서는 `LLM_CONFIDENCE`가 낮아도 매수하고, `BEAR` 국면에서는 `LLM_CONFIDENCE`가 매우 높을 때만 매수하는 식입니다.\n            *   또는, LLM이 직접 'BUY' 신호를 준 경우, `check_technical_entry`의 `min_signals`를 0으로 설정하여 기술적 신호 없이도 매수할 수 있도록 허용하는 실험을 진행합니다.\n        *   **Success metrics**:\n            *   각 시장 국면별 수익률 및 거래 횟수 변화.\n            *   전체 수익률 및 MDD 개선 여부.\n            *   LLM의 의도와 시뮬레이션된 거래 간의 일치도.\n- if_code_change_needed:\n    - `E2EBacktestEngine` 클래스 내에 `_load_llm_decisions_for_date` 함수를 추가하여 `DECISION_LEDGER`에서 LLM 결정을 로드합니다.\n    - `ScoutSnapshot` 데이터 클래스에 `llm_decision_source: str` (e.g., \"DECISION_LEDGER\", \"WATCHLIST_HISTORY\", \"FACTOR_SCORE\") 필드를 추가하여 어떤 소스에서 결정이 왔는지 추적합니다.\n    - `E2EBacktestEngine.run_simulation`의 일별 루프에서 LLM 결정 로드 -> Fallback 로직 적용 -> `hot_watchlist` 구성의 우선순위 로직을 재구성합니다.\n    - `E2EBacktestEngine`의 매수 로직에서 `buy_signal_threshold`를 LLM 결정에 따라 유연하게 적용하도록 수정합니다.\n\n## Questions to the User (optional, <=3)\n- `DECISION_LEDGER` 테이블의 정확한 스키마(컬럼명, 데이터 타입)와 각 컬럼의 의미를 상세히 알려주세요. 특히 LLM의 최종 판단(예: 점수, 신호, 추천 등)을 나타내는 필드가 중요합니다.\n- LLM(Hunter/Debate/Judge) 시스템이 특정 종목에 대해 'BUY' 또는 'SELL'과 같은 직접적인 거래 신호를 생성하는지, 아니면 '점수'나 '확신도'와 같은 간접적인 지표를 생성하는지 명확히 설명해 주실 수 있나요?\n- `DECISION_LEDGER`에 기록된 LLM 결정은 언제 생성된 것인가요? (예: 장 시작 전, 장 마감 후, 실시간) 이는 룩어헤드 방어 로직 설계에 매우 중요합니다.",
  "error": "No JSON found in response"
}
```
### Minji
```json
{
  "text": "# Council Output: Scout E2E 백테스트 LLM 판단 통합\n\n## Verdict\n- **decision**: approve_with_changes\n- **confidence**: 92\n- **scope**: \n  - `ScoutSimulator` → `_load_llm_decisions_for_date()` 추가 (LLM 결정 우선 로드)\n  - `E2EBacktestEngine.run_simulation()` 루프 내 LLM 결정 조회 로직 삽입\n  - Fallback 우선순위: DECISION_LEDGER → WATCHLIST_HISTORY → FactorScore\n  - 룩어헤드 방어 + 데이터 불완전성 처리 필수\n\n---\n\n## Key Findings (≤5)\n\n1. **LLM 판단 이력의 직접 활용이 핵심 격차 해소 수단**\n   - 실제 +45% vs 시뮬레이션 +0.34% = **130배 차이**\n   - 원인: Factor Score는 LLM의 복합 판단(뉴스 해석, 시장 심리, 거래 신호 결합)을 재현 불가\n   - **해결책**: DECISION_LEDGER를 \"Ground Truth\"로 사용 → 시뮬레이션이 실제 LLM 결정을 직접 따름\n\n2. **DECISION_LEDGER는 타당한 Lookup Table이나, 스키마 확인 필수**\n   - 가정: `(DECISION_DATE, STOCK_CODE) → LLM_DECISION_TYPE, LLM_SCORE, LLM_CONFIDENCE`\n   - **위험**: 스키마 미확인 시 잘못된 매핑 → 더 큰 오류 가능\n   - **필수 검증**: 테이블 존재 여부, 데이터 범위(2017~현재?), 결정 생성 시점(장 전/후?)\n\n3. **Fallback 전략의 우선순위가 명확하지 않으면 결과 왜곡**\n   - 현재: LLM 데이터 없으면 무조건 FactorScore 사용\n   - **문제**: WATCHLIST_HISTORY(LLM_SCORE 포함)가 있는데 무시됨\n   - **개선**: DECISION_LEDGER(일중 결정) → WATCHLIST_HISTORY(일일 스냅샷) → FactorScore(Fallback)\n\n4. **룩어헤드 바이어스 방어가 가장 중요한 구현 포인트**\n   - LLM 결정이 \"언제 생성되었는가\"에 따라 타당성 결정\n   - 예: 장 마감 후 생성된 결정을 다음날 매수에 사용 → OK\n   - 예: 실시간 생성된 결정을 당일 매수에 사용 → 시간 검증 필수\n\n5. **데이터 불완전성 처리 전략 필요**\n   - DECISION_LEDGER가 모든 종목/날짜를 커버하지 않을 가능성 높음\n   - 부분 데이터로 인한 편향(bias) 방지 필수\n   - 예: 특정 섹터만 LLM 결정이 있으면, 그 섹터에 과도하게 투자할 수 있음\n\n---\n\n## Evidence\n\n### References\n- **파일**: `backtest_scout_e2e.py`\n  - Line ~1100: `ScoutSimulator.simulate_scout_for_date()` → Factor Score 기반 `estimated_score` 계산\n  - Line ~1300: `E2EBacktestEngine.run_simulation()` → 매일 Scout 시뮬레이션 호출\n  - Line ~1250: `_load_watchlist_history_snapshot()` → WATCHLIST_HISTORY 로드 (현재 옵션)\n  \n- **현재 로직**:\n  ```python\n  if self.use_watchlist_history and i > 0:\n      history_items = self._load_watchlist_history_snapshot(snapshot_date)\n      # LLM_SCORE를 estimated_score로 사용\n  else:\n      scout_result = scout_sim.simulate_scout_for_date(...)  # FactorScore 사용\n  ```\n  → DECISION_LEDGER는 **전혀 사용 안 함**\n\n- **성능 격차**:\n  - 실제 LLM: +45% (삼전 기준)\n  - 시뮬레이터: +0.34% (FactorScore 기반)\n  - **재현율**: 0.76% (0.34/45)\n\n### Missing Data (결론 변경 가능성)\n\n| 항목 | 현재 상태 | 필요 정보 | 영향도 |\n|------|---------|---------|-------|\n| **DECISION_LEDGER 스키마** | 미확인 | 컬럼명, 데이터 타입, 예시 행 | 🔴 Critical |\n| **LLM 결정 생성 시점** | 미확인 | 장 전/후/실시간? | 🔴 Critical |\n| **데이터 커버리지** | 미확인 | 종목 수, 날짜 범위, 결측률 | 🟠 High |\n| **WATCHLIST_HISTORY vs DECISION_LEDGER 관계** | 미확인 | 중복? 보완? 우선순위? | 🟠 High |\n| **LLM 신호 형식** | 추정만 함 | 점수(0-100)? 등급(A-F)? 직접 신호(BUY/SELL)? | 🟡 Medium |\n\n---\n\n## Risks & Veto Triggers\n\n### Risks\n\n| 위험 | 심각도 | 완화 방법 |\n|------|--------|---------|\n| **룩어헤드 바이어스** | 🔴 Critical | DECISION_DATE ≤ current_date 엄격 검증 + 시간 정보 포함 |\n| **데이터 불완전성** | 🔴 Critical | 커버리지 분석 + 편향 감지 로직 추가 |\n| **스키마 오해석** | 🔴 Critical | DB 직접 조회 + 예시 데이터 검증 |\n| **성능 저하** | 🟠 High | 배치 조회 + 인덱스 확인 (DECISION_DATE, STOCK_CODE) |\n| **Fallback 로직 혼동** | 🟠 High | 명시적 우선순위 + 로깅으로 추적 |\n| **LLM 신호 오해석** | 🟡 Medium | 매핑 규칙 문서화 + 검증 테스트 |\n\n### Veto Triggers\n\n❌ **다음 중 하나라도 해결 불가능하면 승인 거부**:\n1. DECISION_LEDGER 테이블이 존재하지 않거나 데이터가 거의 없음 (< 1000건)\n2. LLM 결정 생성 시점이 \"미래\"인 경우 (예: 장 마감 후 생성되는데 당일 매수에 사용)\n3. 룩어헤드 방어 로직 없이 구현하려는 경우\n4. DECISION_LEDGER 데이터가 특정 기간/섹터에만 편향되어 있고, 이를 보정할 방법이 없는 경우\n\n---\n\n## Recommendations\n\n### Immediate Actions (1-3 items, 최소 범위)\n\n#### 1️⃣ **DECISION_LEDGER 스키마 검증 (Approval Required)**\n```sql\n-- 먼저 실행: 테이블 존재 확인 및 스키마 파악\nDESCRIBE DECISION_LEDGER;\nSELECT * FROM DECISION_LEDGER LIMIT 5;\nSELECT COUNT(*), MIN(DECISION_DATE), MAX(DECISION_DATE) FROM DECISION_LEDGER;\n```\n\n**필수 확인 사항**:\n- ✅ 컬럼: `DECISION_DATE`, `STOCK_CODE`, `LLM_DECISION_TYPE` (또는 유사명)\n- ✅ 데이터 타입: DECISION_DATE는 DATE/DATETIME?\n- ✅ 데이터 범위: 2017~현재? 아니면 최근 1년만?\n- ✅ 결정 생성 시점: 로그에 기록되어 있는가?\n\n**산출물**: `DECISION_LEDGER_SCHEMA.md` (스키마 + 예시 + 주의사항)\n\n---\n\n#### 2️⃣ **Fallback 우선순위 명시 + 조건부 로드 함수 추가**\n\n**파일**: `backtest_scout_e2e.py` → `ScoutSimulator` 클래스\n\n**변경 범위**: ~50줄 (새 메서드 추가)\n\n```python\ndef load_llm_decisions_for_date(\n    self,\n    connection,\n    target_date: datetime,\n    stock_codes: List[str],\n    source_priority: List[str] = [\"DECISION_LEDGER\", \"WATCHLIST_HISTORY\", \"FACTOR_SCORE\"]\n) -> Dict[str, dict]:\n    \"\"\"\n    LLM 결정 로드 (우선순위 기반)\n    \n    Returns:\n        {stock_code: {\n            \"source\": \"DECISION_LEDGER\" | \"WATCHLIST_HISTORY\" | \"FACTOR_SCORE\",\n            \"estimated_score\": float,\n            \"llm_decision_type\": str,  # \"BUY\", \"HOLD\", \"SELL\"\n            \"llm_confidence\": float,\n            \"decision_date\": datetime,\n        }}\n    \"\"\"\n    results = {}\n    \n    # 1. DECISION_LEDGER 우선 조회 (있으면 사용)\n    if \"DECISION_LEDGER\" in source_priority:\n        try:\n            cursor = connection.cursor()\n            cursor.execute(\"\"\"\n                SELECT STOCK_CODE, LLM_DECISION_TYPE, LLM_SCORE, LLM_CONFIDENCE, DECISION_DATE\n                FROM DECISION_LEDGER\n                WHERE DECISION_DATE = %s AND STOCK_CODE IN ({})\n            \"\"\".format(','.join(['%s'] * len(stock_codes))),\n            (target_date.strftime(\"%Y-%m-%d\"), *stock_codes))\n            \n            for row in cursor.fetchall():\n                code = row[0] if isinstance(row, tuple) else row[\"STOCK_CODE\"]\n                decision_type = row[1] if isinstance(row, tuple) else row[\"LLM_DECISION_TYPE\"]\n                score = row[2] if isinstance(row, tuple) else row[\"LLM_SCORE\"]\n                confidence = row[3] if isinstance(row, tuple) else row[\"LLM_CONFIDENCE\"]\n                decision_date = row[4] if isinstance(row, tuple) else row[\"DECISION_DATE\"]\n                \n                # 룩어헤드 방어: DECISION_DATE <= target_date 확인\n                if pd.to_datetime(decision_date) <= target_date:\n                    results[code] = {\n                        \"source\": \"DECISION_LEDGER\",\n                        \"estimated_score\": float(score) if score else 50.0,\n                        \"llm_decision_type\": decision_type,\n                        \"llm_confidence\": float(confidence) if confidence else 0.5,\n                        \"decision_date\": decision_date,\n                    }\n            cursor.close()\n        except Exception as e:\n            logger.warning(f\"DECISION_LEDGER 조회 실패: {e}\")\n    \n    # 2. WATCHLIST_HISTORY 보완 (DECISION_LEDGER에 없는 종목)\n    if \"WATCHLIST_HISTORY\" in source_priority:\n        missing_codes = [c for c in stock_codes if c not in results]\n        if missing_codes:\n            try:\n                cursor = connection.cursor()\n                cursor.execute(\"\"\"\n                    SELECT STOCK_CODE, LLM_SCORE, IS_TRADABLE\n                    FROM WATCHLIST_HISTORY\n                    WHERE SNAPSHOT_DATE = %s AND STOCK_CODE IN ({})\n                \"\"\".format(','.join(['%s'] * len(missing_codes))),\n                (target_date.strftime(\"%Y-%m-%d\"), *missing_codes))\n                \n                for row in cursor.fetchall():\n                    code = row[0] if isinstance(row, tuple) else row[\"STOCK_CODE\"]\n                    score = row[1] if isinstance(row, tuple) else row[\"LLM_SCORE\"]\n                    is_tradable = row[2] if isinstance(row, tuple) else row[\"IS_TRADABLE\"]\n                    \n                    if is_tradable:\n                        results[code] = {\n                            \"source\": \"WATCHLIST_HISTORY\",\n                            \"estimated_score\": float(score) if score else 50.0,\n                            \"llm_decision_type\": \"BUY\" if score and score > 70 else \"HOLD\",\n                            \"llm_confidence\": 0.7,\n                            \"decision_date\": target_date,\n                        }\n                cursor.close()\n            except Exception as e:\n                logger.warning(f\"WATCHLIST_HISTORY 조회 실패: {e}\")\n    \n    return results\n```\n\n**테스트**:\n```python\n# 단위 테스트\nengine = E2EBacktestEngine(...)\nengine.load_data()\nllm_decisions = engine.scout_sim.load_llm_decisions_for_date(\n    connection, \n    datetime(2024, 1, 15),\n    [\"005930\", \"000660\"]  # 삼성전자, SK하이닉스\n)\nassert \"005930\" in llm_decisions\nassert llm_decisions[\"005930\"][\"source\"] in [\"DECISION_LEDGER\", \"WATCHLIST_HISTORY\"]\n```\n\n---\n\n#### 3️⃣ **E2EBacktestEngine.run_simulation() 내 LLM 결정 통합**\n\n**파일**: `backtest_scout_e2e.py` → `E2EBacktestEngine.run_simulation()` 메서드\n\n**변경 범위**: ~30줄 (Scout 시뮬레이션 부분 수정)\n\n**Before** (현재):\n```python\nscout_result = scout_sim.simulate_scout_for_date(current_date, universe_codes=daily_universe)\n```\n\n**After** (개선):\n```python\n# 1. LLM 결정 우선 로드\nllm_decisions = scout_sim.load_llm_decisions_for_date(\n    self.connection,\n    current_date,\n    daily_universe,\n    source_priority=[\"DECISION_LEDGER\", \"WATCHLIST_HISTORY\", \"FACTOR_SCORE\"]\n)\n\n# 2. LLM 결정이",
  "error": "JSON Parse Failed: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)",
  "raw_json_snippet": "{stock_code: {\n            \"source\": \"DECISION_LEDGER\" | \"WATCHLIST_HISTORY\" | \"FACTOR_SCORE\",\n            \"estimated_score\": float,\n            \"llm_decision_type\": str,  # \"BUY\", \"HOLD\", \"SELL\"\n    "
}
```
### Junho
```json
{
  "text": "## Verdict\n- decision: approve_with_changes\n- confidence: 95\n- scope: \n  - `ScoutSimulator` → `_load_llm_decisions_for_date()` 추가 (LLM 결정 우선 로드)\n  - `E2EBacktestEngine.run_simulation()` 루프 내 LLM 결정 조회 로직 삽입\n  - Fallback 우선순위: DECISION_LEDGER → WATCHLIST_HISTORY → FactorScore\n  - 룩어헤드 방어 + 데이터 불완전성 처리 필수\n\n## Key Findings (<=5)\n1. **LLM 판단 이력의 직접 활용이 핵심 격차 해소 수단**\n   - 실제 +45% vs 시뮬레이션 +0.34% = **130배 차이**\n   - 원인: Factor Score는 LLM의 복합 판단(뉴스 해석, 시장 심리, 거래 신호 결합)을 재현 불가\n   - **해결책**: DECISION_LEDGER를 \"Ground Truth\"로 사용 → 시뮬레이션이 실제 LLM 결정을 직접 따름\n\n2. **DECISION_LEDGER는 타당한 Lookup Table이나, 스키마 확인 필수**\n   - 가정: `(DECISION_DATE, STOCK_CODE) → LLM_DECISION_TYPE, LLM_SCORE, LLM_CONFIDENCE`\n   - **위험**: 스키마 미확인 시 잘못된 매핑 → 더 큰 오류 가능\n   - **필수 검증**: 테이블 존재 여부, 데이터 범위(2017~현재?), 결정 생성 시점(장 전/후?)\n\n3. **Fallback 전략의 우선순위가 명확하지 않으면 결과 왜곡**\n   - 현재: LLM 데이터 없으면 무조건 FactorScore 사용\n   - **문제**: WATCHLIST_HISTORY(LLM_SCORE 포함)가 있는데 무시됨\n   - **개선**: DECISION_LEDGER(일중 결정) → WATCHLIST_HISTORY(일일 스냅샷) → FactorScore(Fallback)\n\n4. **룩어헤드 바이어스 방어가 가장 중요한 구현 포인트**\n   - LLM 결정이 \"언제 생성되었는가\"에 따라 타당성 결정\n   - 예: 장 마감 후 생성된 결정을 다음날 매수에 사용 → OK\n   - 예: 실시간 생성된 결정을 당일 매수에 사용 → 시간 검증 필수\n\n5. **데이터 불완전성 처리 전략 필요**\n   - DECISION_LEDGER가 모든 종목/날짜를 커버하지 않을 가능성 높음\n   - 부분 데이터로 인한 편향(bias) 방지 필수\n   - 예: 특정 섹터만 LLM 결정이 있으면, 그 섹터에 과도하게 투자할 수 있음\n\n## Evidence\n- references:\n  - **파일**: `backtest_scout_e2e.py`\n    - Line ~1100: `ScoutSimulator.simulate_scout_for_date()` → Factor Score 기반 `estimated_score` 계산\n    - Line ~1300: `E2EBacktestEngine.run_simulation()` → 매일 Scout 시뮬레이션 호출\n    - Line ~1250: `_load_watchlist_history_snapshot()` → WATCHLIST_HISTORY 로드 (현재 옵션)\n    \n- **현재 로직**:\n  ```python\n  if self.use_watchlist_history and i > 0:\n      history_items = self._load_watchlist_history_snapshot(snapshot_date)\n      # LLM_SCORE를 estimated_score로 사용\n  else:\n      scout_result = scout_sim.simulate_scout_for_date(...)  # FactorScore 사용\n  ```\n  → DECISION_LEDGER는 **전혀 사용 안 함**\n\n- **성능 격차**:\n  - 실제 LLM: +45% (삼전 기준)\n  - 시뮬레이터: +0.34% (FactorScore 기반)\n  - **재현율**: 0.76% (0.34/45)\n\n## Risks & Veto Triggers\n- risks:\n  - **룩어헤드 바이어스**: DECISION_DATE ≤ current_date 엄격 검증 + 시간 정보 포함\n  - **데이터 불완전성**: 커버리지 분석 + 편향 감지 로직 추가\n  - **스키마 오해석**: DB 직접 조회 + 예시 데이터 검증\n  - **성능 저하**: 배치 조회 + 인덱스 확인 (DECISION_DATE, STOCK_CODE)\n  - **Fallback 로직 혼동**: 명시적 우선순위 + 로깅으로 추적\n  - **LLM 신호 오해석**: 매핑 규칙 문서화 + 검증 테스트\n\n- veto_if:\n  - DECISION_LEDGER 테이블이 존재하지 않거나 데이터가 거의 없음 (< 1000건)\n  - LLM 결정 생성 시점이 \"미래\"인 경우 (예: 장 마감 후 생성되는데 당일 매수에 사용)\n  - 룩어헤드 방어 로직 없이 구현하려는 경우\n  - DECISION_LEDGER 데이터가 특정 기간/섹터에만 편향되어 있고, 이를 보정할 방법이 없는 경우\n\n## Recommendations\n- immediate_actions:\n  1. **DECISION_LEDGER 스키마 검증 (Approval Required)**\n  2. **Fallback 우선순위 명시 + 조건부 로드 함수 추가**\n  3. **E2EBacktestEngine.run_simulation() 내 LLM 결정 통합**\n\n## Questions to the User (optional, <=3)\n- DECISION_LEDGER 테이블의 정확한 스키마(컬럼명, 데이터 타입)와 각 컬럼의 의미를 상세히 알려주세요. 특히 LLM의 최종 판단(예: 점수, 신호, 추천 등)을 나타내는 필드가 중요합니다.\n- LLM(Hunter/Debate/Judge) 시스템이 특정 종목에 대해 'BUY' 또는 'SELL'과 같은 직접적인 거래 신호를 생성하는지, 아니면 '점수'나 '확신도'와 같은 간접적인 지표를 생성하는지 명확히 설명해 주실 수 있나요?\n- DECISION_LEDGER에 기록된 LLM 결정은 언제 생성된 것인가요? (예: 장 시작 전, 장 마감 후, 실시간) 이는 룩어헤드 방어 로직 설계에 매우 중요합니다.",
  "error": "No JSON found in response"
}
```

</details>

---
## Cost Summary
| Model | Input | Output | Cost (USD) |
|-------|-------|--------|------------|
| Jennie (Gemini) | 0 | 0 | $0.0000 |
| Minji (Claude) | 20,741 | 2,870 | $0.5264 |
| Junho (OpenAI) | 0 | 0 | $0.0000 |
| Orchestrator (OpenAI) | 6,588 | 573 | $0.0013 |
| **Total** | - | - | **$0.5277** (≈765원) |
