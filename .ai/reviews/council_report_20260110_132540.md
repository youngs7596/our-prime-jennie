# Prime Council Report
- Date: 2026-01-10 13:26:53
- Query: JSON 파싱 로직이 제대로 개선되었는지 확인해줘
- Target: scripts/ask_prime_council.py

# Final Plan

## 1) 승인된 범위 (Approved scope)
- `_safe_generate()` 함수 내 LLM 응답 JSON 파싱 로직 및 테스트 커버리지 추가

## 2) 실행 순서가 있는 액션 스텝 (Action Steps)
1. **정규식 개선**: 중첩 JSON 객체를 올바르게 처리할 수 있도록 정규식을 수정합니다.
   - 개선안: greedy + 중괄호 카운팅을 활용한 새로운 JSON 추출 로직 도입
2. **시크릿 마스킹 강화**: 로그에 시크릿이 노출되지 않도록 마스킹 로직을 개선합니다.
3. **에러 상태 처리 개선**: `_safe_generate()` 함수에서 오류 발생 시 적절한 처리를 추가하여 파이프라인 오염 방지.
4. **테스트 케이스 확장**: 다양한 LLM 응답 시나리오를 포함하는 단위 테스트를 `_safe_generate()` 함수의 파싱 로직에 추가하여 견고성을 검증합니다.
5. **실제 응답 샘플 수집**: 다양한 LLM 모델로부터 응답 샘플을 수집하여 테스트 데이터셋을 구축합니다.
6. **성공률 측정**: 개선된 로직을 적용한 후 파싱 성공률을 측정하고, 기존 로직과 비교하여 개선 효과를 정량화합니다.
7. **모니터링 및 롤백 계획 수립**: 개선 로직 배포 후 1주일 모니터링하고, `JSONDecodeError` 발생률 증가 시 이전 버전으로 롤백합니다.

## 3) 실험 (Experiments) 및 수용 기준 (Acceptance criteria)
- **가설**: 개선된 정규식과 폴백 로직을 통해 JSON 파싱 성공률이 95% 이상 달성될 것이다.
- **방법**:
  1. 다양한 LLM 응답 샘플을 수집하여 테스트합니다.
  2. 현재 로직과 개선된 로직의 파싱 성공률을 비교합니다.
- **성공 기준**:
  - 유효한 JSON 포함 응답에 대한 파싱 성공률 95% 이상.
  - 중첩 객체 (깊이 3+)에 대한 파싱 성공률 100%.
  - 파싱 실패 시 명확한 에러 메시지 및 로그 기록.

## 4) 리스크 및 롤백 트리거 (Risk & rollback triggers)
- **리스크**:
  - 정규식의 비효율성: 중첩 JSON 객체 손실로 인해 파이프라인 데이터가 손상될 수 있습니다.
  - 에러 상태의 전파: 오류가 발생한 상태에서 파이프라인이 계속 진행되어 최종 리포트의 신뢰성이 저하될 수 있습니다.
- **롤백 트리거**:
  - 프로덕션 배포 전 최소 20개 실제 LLM 응답 샘플에 대한 파싱 성공률 테스트 미실행.
  - 중첩 JSON 객체 포함 응답에서 파싱 실패율 > 5%.
  - `JSONDecodeError` 발생률 증가 시 즉시 이전 버전 복구.

## Notes
- 제니와 민지의 이견은 보존되었으며, 각자의 분석에서 제기된 문제점들은 개선 계획에 반영되었습니다.

---
## Appendix: Raw JSON Outputs
<details><summary>Click to expand</summary>

### Jennie
```json
{
  "text": "## Verdict\n- decision: approve_with_changes\n- confidence: 88\n- scope: `_safe_generate` 함수 내 LLM 응답 JSON 파싱 로직\n\n## Key Findings\n1.  **향상된 JSON 추출 로직:** `re.search`를 활용하여 마크다운 코드 블록 내 JSON을 우선적으로 추출하고, 실패 시 최외곽 중괄호를 찾는 폴백 로직을 도입하여 LLM 응답의 다양한 형식에 대한 견고성이 크게 향상되었습니다.\n2.  **명확한 오류 처리:** `json.JSONDecodeError` 발생 시 오류 메시지와 함께 `raw_json_snippet`을 반환하도록 하여 디버깅 및 문제 해결에 필요한 정보를 제공합니다. 이는 파싱 실패로 인한 불필요한 `veto` 트리거를 줄이는 데 기여합니다.\n3.  **하위 단계 안정성 증대:** Jennie, Minji, Junho 각 단계에서 생성된 JSON 출력이 안정적으로 파싱됨으로써, 다음 단계로 전달되는 데이터의 신뢰성이 높아져 전체 파이프라인의 안정성이 개선되었습니다.\n4.  **잠재적 엣지 케이스:** 매우 복잡하거나 의도적으로 오염된 LLM 응답의 경우, 현재의 정규식이나 최외곽 중괄호 탐색만으로는 완벽한 JSON 추출이 어려울 수 있습니다.\n\n## Evidence\n- references:\n    - `scripts/ask_prime_council.py`\n    - `_safe_generate` function, specifically lines:\n        ```python\n        json_match = re.search(r'```(?:json)?\\s*(\\{.*?\\})\\s*```', text_content, re.DOTALL)\n        if json_match:\n            json_str = json_match.group(1)\n        else:\n            start = text_content.find(\"{\")\n            end = text_content.rfind(\"}\") + 1\n            if start != -1 and end > start:\n                json_str = text_content[start:end]\n            else:\n                return {\"text\": text_content, \"error\": \"No JSON found in response\"}\n        try:\n            return json.loads(json_str)\n        except json.JSONDecodeError as je:\n            return {\n                \"text\": text_content,\n                \"error\": f\"JSON Parse Failed: {je}\",\n                \"raw_json_snippet\": json_str[:200]\n            }\n        ```\n- missing_data:\n    - 과거 LLM 응답 중 JSON 파싱에 실패했던 실제 사례 (다양한 형식의 텍스트 포함)가 있다면, 개선된 로직의 효과를 정량적으로 검증하고 추가적인 개선점을 찾는 데 도움이 될 것입니다.\n\n## Risks & Veto Triggers\n- risks:\n    - **정규식의 한계:** LLM이 예상치 못한 방식으로 JSON을 출력하거나, JSON과 유사하지만 유효하지 않은 텍스트를 포함할 경우, 정규식이 잘못된 부분을 추출하거나 유효한 JSON을 놓칠 수 있습니다.\n    - **성능 오버헤드:** 매우 긴 LLM 응답 텍스트에 대해 정규식 검색을 수행하는 것은 미미하지만 잠재적인 성능 오버헤드를 발생시킬 수 있습니다.\n- veto_if:\n    - 개선된 파싱 로직 적용 후에도 LLM 응답의 JSON 파싱 성공률이 특정 임계치(예: 90%) 이하로 지속적으로 떨어지는 경우.\n    - 파싱된 JSON 데이터가 빈번하게 손상되거나, 예상과 다른 구조를 가져 하위 단계의 로직에 심각한 오류를 유발하는 경우.\n\n## Recommendations\n- immediate_actions:\n    1.  **로그 상세화:** `JSONDecodeError` 발생 시 `raw_json_snippet` 외에 전체 `text_content`를 마스킹 처리하여 로그에 기록하는 옵션을 추가하여, 어떤 원본 텍스트에서 파싱 오류가 발생했는지 더 쉽게 파악할 수 있도록 합니다.\n    2.  **테스트 케이스 확장:** 다양한 LLM 응답 시나리오(정상, 마크다운 포함, 앞뒤 텍스트 포함, 부분 손상, 비 JSON 텍스트 등)를 포함하는 단위 테스트를 `_safe_generate` 함수의 파싱 로직에 추가하여 견고성을 검증합니다.\n- experiments:\n    - **hypothesis:** 현재의 JSON 파싱 로직은 다양한 LLM 응답 형식에 대해 높은 성공률로 유효한 JSON을 추출하며, 기존 방식 대비 파싱 실패율을 유의미하게 감소시킨다.\n    - **method:**\n        1.  다양한 LLM 모델(Gemini, Claude, OpenAI 등)로부터 얻은 실제 응답 샘플 데이터셋을 구축합니다. 이 데이터셋에는 유효한 JSON, 마크다운으로 감싸진 JSON, 앞뒤에 설명 텍스트가 붙은 JSON, 의도적으로 손상된 JSON, 그리고 JSON이 아닌 텍스트를 포함합니다.\n        2.  현재 `_safe_generate` 함수의 파싱 로직을 이 데이터셋에 적용하여 파싱 성공률, 실패율, 그리고 추출된 JSON의 유효성을 측정합니다.\n        3.  (선택 사항) 단순 `json.loads(text_content)` 방식이나 더 간단한 정규식 방식과 비교하여 개선 효과를 정량화합니다.\n    - **success_metrics:**\n        -   유효한 JSON을 포함하는 응답에 대한 파싱 성공률 95% 이상.\n        -   유효하지 않은 JSON 또는 비 JSON 응답에 대해 올바르게 오류를 감지하는 비율 90% 이상.\n        -   프로덕션 환경에서 `JSONDecodeError` 발생 빈도 50% 이상 감소.\n- if_code_change_needed:\n    - LLM 응답에서 JSON 추출을 위한 정규식을 더욱 정교하게 다듬거나, 여러 단계의 추출 전략(예: 먼저 마크다운 블록을 찾고, 없으면 최외곽 중괄호 탐색 후, 그래도 없으면 특정 키워드를 포함하는 JSON 패턴 탐색)을 도입하여 엣지 케이스에 대한 대응력을 높일 수 있습니다.\n\n## Questions to the User\n- LLM 응답에서 JSON 파싱이 특히 어려웠던 구체적인 사례(원본 텍스트)가 있다면 공유해 주실 수 있나요?\n- 각 현자(Jennie, Minji, Junho)의 LLM 응답에서 JSON 출력의 예상되는 최대 크기는 어느 정도인가요? (정규식 성능 평가를 위함)",
  "error": "JSON Parse Failed: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)",
  "raw_json_snippet": "{.*?\\})\\s*```', text_content, re.DOTALL)\n        if json_match:\n            json_str = json_match.group(1)\n        else:\n            start = text_content.find(\"{\")\n            end = text_content.rfind"
}
```
### Minji
```json
{
  "text": "# Prime Council Output: Minji (Lead Engineer & Fixer)\n\n## Verdict\n- decision: **approve_with_changes**\n- confidence: 72\n- scope: `_safe_generate()` 함수의 JSON 파싱 로직 + 테스트 커버리지 추가\n\n---\n\n## Key Findings\n\n1. **Jennie의 분석 자체가 파싱 실패로 손상됨**\n   - Jennie의 응답이 JSON 형식이 아닌 마크다운 텍스트로 반환되었고, 현재 `_safe_generate()`의 정규식이 이를 제대로 추출하지 못했습니다.\n   - 이는 **현재 로직이 실제 환경에서 작동하지 않음**을 증명합니다.\n\n2. **정규식 패턴의 근본적 결함**\n   ```python\n   json_match = re.search(r'```(?:json)?\\s*(\\{.*?\\})\\s*```', text_content, re.DOTALL)\n   ```\n   - `\\{.*?\\}` (non-greedy)는 **첫 번째 `}` 에서 멈춤** → 중첩된 JSON 객체 실패\n   - 예: `{\"a\": {\"b\": 1}}` → `{\"a\": {\"b\": 1}` 만 추출 (마지막 `}` 누락)\n\n3. **폴백 로직도 불완전**\n   ```python\n   start = text_content.find(\"{\")\n   end = text_content.rfind(\"}\") + 1\n   ```\n   - 텍스트에 여러 `{}`가 있으면 **첫 `{`부터 마지막 `}`까지** 모두 포함 → 쓰레기 데이터 혼입 가능\n   - 예: `Some text { invalid } ... { \"valid\": \"json\" }` → 전체 범위 추출\n\n4. **에러 처리 후 파이프라인 진행**\n   - `_safe_generate()`가 `{\"error\": \"...\", \"decision\": \"veto\"}` 반환 시, 다음 단계(Minji, Junho)는 이를 유효한 JSON으로 처리하여 **오염된 컨텍스트** 전달\n\n5. **시크릿 로딩 위험**\n   ```python\n   if SECRETS_FILE.exists():\n       secrets = json.loads(SECRETS_FILE.read_text())\n       for k, v in secrets.items():\n           if k == \"openai-api-key\": os.environ[\"OPENAI_API_KEY\"] = v\n   ```\n   - `secrets.json`이 실수로 로그/에러 메시지에 노출될 수 있음 (현재 마스킹 불충분)\n\n---\n\n## Evidence\n\n- **references:**\n  - `scripts/ask_prime_council.py` lines 95-115 (`_safe_generate` 함수)\n  - Jennie 응답: `\"error\": \"JSON Parse Failed: Expecting property name...\"` \n    - 원인: 마크다운 텍스트 → 정규식 실패 → 최외곽 `{}` 추출 시도 → 부분 JSON 추출 → `json.loads()` 실패\n\n- **missing_data:**\n  - 실제 Gemini/Claude/OpenAI 응답 샘플 (마크다운 형식, 중첩 깊이, 길이)\n  - 과거 파싱 실패 로그 (어떤 형식에서 자주 실패했는지)\n  - 각 LLM의 JSON 출력 스키마 정의 (필수 필드, 최대 깊이)\n\n---\n\n## Risks & Veto Triggers\n\n- **risks:**\n  1. **정규식 non-greedy 한계**: 중첩 JSON 객체 손실 → 파이프라인 데이터 손상\n  2. **폴백 로직의 과도한 범위**: 여러 `{}` 존재 시 잘못된 범위 추출\n  3. **에러 상태의 전파**: `{\"error\": \"...\"}` 반환 후에도 파이프라인 계속 진행 → 최종 리포트 신뢰성 저하\n  4. **시크릿 노출**: `secrets.json` 내용이 예외 메시지/로그에 포함될 가능성\n  5. **테스트 부재**: 현재 코드에 단위 테스트 없음 → 개선 검증 불가능\n\n- **veto_if:**\n  - 프로덕션 배포 전 **최소 20개 실제 LLM 응답 샘플에 대한 파싱 성공률 테스트 미실행**\n  - 중첩 JSON 객체 포함 응답에서 파싱 실패율 > 5%\n  - 시크릿 마스킹 없이 배포\n\n---\n\n## Recommendations\n\n### immediate_actions\n\n1. **정규식 개선 (필수)**\n   ```python\n   # 현재 (결함)\n   json_match = re.search(r'```(?:json)?\\s*(\\{.*?\\})\\s*```', text_content, re.DOTALL)\n   \n   # 개선안: greedy + 중괄호 카운팅\n   def extract_json_from_markdown(text):\n       \"\"\"마크다운 코드 블록에서 JSON 추출\"\"\"\n       match = re.search(r'```(?:json)?\\s*(\\{.+?\\})\\s*```', text, re.DOTALL)\n       if match:\n           return match.group(1)\n       return None\n   \n   def extract_json_by_braces(text):\n       \"\"\"최외곽 중괄호 기반 추출 (괄호 카운팅)\"\"\"\n       start = text.find(\"{\")\n       if start == -1:\n           return None\n       \n       count = 0\n       for i in range(start, len(text)):\n           if text[i] == \"{\":\n               count += 1\n           elif text[i] == \"}\":\n               count -= 1\n               if count == 0:\n                   return text[start:i+1]\n       return None\n   ```\n\n2. **시크릿 마스킹 강화**\n   ```python\n   def _mask_secrets(text: str) -> str:\n       \"\"\"API 키/토큰 마스킹\"\"\"\n       if not text:\n           return \"\"\n       \n       patterns = [\n           (r'sk-[a-zA-Z0-9]{20,}', '[OPENAI_KEY_MASKED]'),\n           (r'AIza[0-9A-Za-z\\-_]{35}', '[GEMINI_KEY_MASKED]'),\n           (r'sk-ant-[a-zA-Z0-9]{20,}', '[CLAUDE_KEY_MASKED]'),\n       ]\n       \n       masked = text\n       for pattern, replacement in patterns:\n           masked = re.sub(pattern, replacement, masked)\n       return masked\n   ```\n\n3. **에러 상태 처리 개선**\n   ```python\n   def _safe_generate(provider, system_prompt, user_query, context, prev_reports):\n       # ... 기존 코드 ...\n       \n       try:\n           res = provider.generate_chat(history)\n           text_content = res.get(\"text\") or res.get(\"content\", \"\")\n           \n           # 단계별 추출 시도\n           json_str = extract_json_from_markdown(text_content)\n           if not json_str:\n               json_str = extract_json_by_braces(text_content)\n           \n           if not json_str:\n               logger.warning(f\"No JSON found in response. Raw (masked): {_mask_secrets(text_content[:500])}\")\n               return {\n                   \"error\": \"No JSON found in response\",\n                   \"decision\": \"veto\",\n                   \"text_preview\": text_content[:200]\n               }\n           \n           try:\n               return json.loads(json_str)\n           except json.JSONDecodeError as je:\n               logger.error(f\"JSON Parse Failed: {je}. Snippet: {json_str[:100]}\")\n               return {\n                   \"error\": f\"JSON Parse Failed: {str(je)}\",\n                   \"decision\": \"veto\"\n               }\n       \n       except Exception as e:\n           logger.error(f\"LLM Error: {_mask_secrets(str(e))}\")\n           return {\"error\": str(e), \"decision\": \"veto\"}\n   ```\n\n### experiments\n\n- **hypothesis:** \n  괄호 카운팅 기반 JSON 추출은 중첩 객체를 올바르게 처리하며, 마크다운 + 폴백 2단계 전략으로 95% 이상의 파싱 성공률을 달성한다.\n\n- **method:**\n  1. 테스트 파일 생성: `tests/test_json_parsing.py`\n  2. 샘플 LLM 응답 20개 수집 (Gemini/Claude/OpenAI 각 6-7개)\n  3. 현재 로직 vs 개선 로직 비교 테스트\n  4. 성공/실패 케이스 분류\n\n- **success_metrics:**\n  - 유효한 JSON 포함 응답: **파싱 성공률 ≥ 95%**\n  - 중첩 객체 (깊이 3+): **100% 성공**\n  - 파싱 실패 시 명확한 에러 메시지 + 로그 기록\n  - 시크릿 노출 0건\n\n### if_code_change_needed\n\n**Scope: `_safe_generate()` 함수 + 새 헬퍼 함수 2개 + 테스트**\n\n**파일:** `scripts/ask_prime_council.py`\n\n**변경 범위:**\n- Lines 95-115: `_safe_generate()` 함수 전체 리팩토링\n- Lines 50-90: 새 헬퍼 함수 추가 (`extract_json_from_markdown`, `extract_json_by_braces`)\n- Lines 30-45: `_mask_secrets()` 함수 확장\n\n**테스트 파일 신규 생성:**\n```\ntests/test_json_parsing.py\n- test_extract_json_from_markdown()\n- test_extract_json_by_braces()\n- test_nested_json_objects()\n- test_malformed_json_handling()\n```\n\n**롤백 계획:**\n- 개선 로직 배포 후 1주일 모니터링\n- `JSONDecodeError` 발생률 증가 시 즉시 이전 버전 복구\n- 메트릭: `council.json_parse_error_rate` (CloudWatch/Datadog)\n\n**관측/검증:**\n```python\n# 로그 추가\nlogger.info(f\"JSON extraction method: {extraction_method}\")  # 'markdown' | 'braces' | 'failed'\nlogger.info(f\"JSON parse success: {json_str[:50]}...\")\n```\n\n---\n\n## Questions to the User\n\n1. **Jennie의 응답이 마크다운 텍스트로 반환된 이유는?**\n   - 시스템 프롬프트(`prompts/council/jennie_system.txt`)에서 JSON 출력을 명시적으로 요구하고 있나요?\n   - 아니면 LLM이 자의적으로 마크다운 형식을 선택한 건가요?\n\n2. **각 현자(Jennie/Minji/Junho)의 응답 JSON 스키마가 정의되어 있나요?**\n   - 필수 필드, 최대 깊이, 예상 크기를 알면 더 정확한 파싱 로직을 설계할 수 있습니다.\n\n3. **프로덕션 환경에서 과거 파싱 실패 로그가 있나요?**\n   - 실제 실패 사례를 분석하면 정규식 개선의 우선순위를 정할 수 있습니다.\n\n---\n\n**다음 단계:** 위 개선안을 `scripts/ask_prime_council.py`에 적용 후, `tests/test_json_parsing.py`로 검증하면 Jennie의 분석도 정상 작동할 것으로 예상됩니다. 🔧",
  "error": "JSON Parse Failed: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)",
  "raw_json_snippet": "{.*?\\})\\s*```', text_content, re.DOTALL)\n   ```\n   - `\\{.*?\\}` (non-greedy)는 **첫 번째 `}` 에서 멈춤** → 중첩된 JSON 객체 실패\n   - 예: `{\"a\": {\"b\": 1}}` → `{\"a\": {\"b\": 1}` 만 추출 (마지막 `}` 누락)\n\n3. **폴백 로직도 불완전**\n   ``"
}
```
### Junho
```json
{
  "text": "## Verdict\n- decision: approve_with_changes\n- confidence: 85\n- scope: `scripts/ask_prime_council.py` 내 `_safe_generate()` 함수의 JSON 파싱 로직 및 테스트 커버리지 추가\n\n## Key Findings\n1. **Jennie와 Minji의 분석에서 JSON 파싱 실패가 발생**: 현재 로직이 마크다운 형식의 응답을 제대로 처리하지 못하고 있으며, 이는 파이프라인의 신뢰성을 저하시킵니다.\n2. **정규식의 한계**: 중첩된 JSON 객체를 처리하는 데 있어 현재의 정규식이 비효율적이며, 폴백 로직이 잘못된 범위를 추출할 위험이 있습니다.\n3. **에러 상태 전파 문제**: `_safe_generate()`가 오류를 반환할 경우, 다음 단계에서 이를 유효한 JSON으로 처리하여 파이프라인에 오염된 데이터를 전달할 수 있습니다.\n4. **시크릿 노출 위험**: `secrets.json`의 내용이 로그에 노출될 수 있는 가능성이 있으며, 이는 보안 문제를 야기할 수 있습니다.\n\n## Evidence\n- references:\n  - `scripts/ask_prime_council.py` 내 `_safe_generate()` 함수\n  - Jennie와 Minji의 응답에서 JSON 파싱 실패 관련 오류 메시지\n- missing_data:\n  - 다양한 LLM 응답 샘플 (마크다운 형식, 중첩 깊이, 길이)\n  - 과거 파싱 실패 로그 (어떤 형식에서 자주 실패했는지)\n\n## Risks & Veto Triggers\n- risks:\n  - **정규식의 비효율성**: 중첩 JSON 객체 손실로 인해 파이프라인 데이터가 손상될 수 있습니다.\n  - **에러 상태의 전파**: 오류가 발생한 상태에서 파이프라인이 계속 진행되어 최종 리포트의 신뢰성이 저하될 수 있습니다.\n- veto_if:\n  - 프로덕션 배포 전 최소 20개 실제 LLM 응답 샘플에 대한 파싱 성공률 테스트 미실행\n  - 중첩 JSON 객체 포함 응답에서 파싱 실패율 > 5%\n\n## Recommendations\n- immediate_actions:\n  1. **정규식 개선**: 중첩 JSON 객체를 올바르게 처리할 수 있도록 정규식을 수정합니다.\n  2. **시크릿 마스킹 강화**: 로그에 시크릿이 노출되지 않도록 마스킹 로직을 개선합니다.\n  3. **에러 상태 처리 개선**: `_safe_generate()` 함수에서 오류 발생 시 적절한 처리를 추가합니다.\n  \n- experiments:\n  - **hypothesis**: 개선된 정규식과 폴백 로직을 통해 JSON 파싱 성공률이 95% 이상 달성될 것이다.\n  - **method**:\n    1. 다양한 LLM 응답 샘플을 수집하여 테스트합니다.\n    2. 현재 로직과 개선된 로직의 파싱 성공률을 비교합니다.\n  - **success_metrics**:\n    - 유효한 JSON 포함 응답에 대한 파싱 성공률 95% 이상.\n\n- if_code_change_needed:\n  - `_safe_generate()` 함수의 리팩토링 및 새로운 헬퍼 함수 추가가 필요합니다.\n\n## Questions to the User\n1. **Jennie의 응답이 마크다운 텍스트로 반환된 이유는 무엇인가요?** 시스템 프롬프트에서 JSON 출력을 명시적으로 요구하고 있나요?\n2. **각 현자(Jennie/Minji/Junho)의 응답 JSON 스키마가 정의되어 있나요?** 필수 필드와 최대 깊이를 알면 더 정확한 파싱 로직을 설계할 수 있습니다.\n3. **프로덕션 환경에서 과거 파싱 실패 로그가 있나요?** 실제 실패 사례를 분석하면 정규식 개선의 우선순위를 정할 수 있습니다.",
  "error": "No JSON found in response"
}
```

</details>